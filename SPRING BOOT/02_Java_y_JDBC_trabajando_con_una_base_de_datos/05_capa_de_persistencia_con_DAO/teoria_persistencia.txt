




				 Creando el modelo producto
				 
estamos representando los parametros como variables sueltas sin representacion del producto como en la base de datos
por eso vamos a crear un objeto/modelo del producto


package com.alura.jdbc.modelo;

public class Producto {

	public Producto(String nombre, String descripcion , Integer cantidad) {
		// TODO Auto-generated constructor stub
		this.nombre=nombre;
		this.descripcion=descripcion;
		this.cantidad=cantidad;
		
	}
	
	private Integer id;
	private String nombre;
	private String descripcion;
	private Integer cantidad;
	
	
	
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getDescripcion() {
		return descripcion;
	}
	public void setDescripcion(String descripcion) {
		this.descripcion = descripcion;
	}
	public Integer getCantidad() {
		return cantidad;
	}
	public void setCantidad(Integer cantidad) {
		this.cantidad = cantidad;
	}
	public void setId(int id) {
		// TODO Auto-generated method stub
		this.id=id;
	}
	@Override
	public String toString() {
		return String.format(
				"{id: ,%s, nombre: , %s, descripcion: ,%s, cantidad: ,%d}",
				this.id, this.nombre, this.descripcion, this.cantidad);
	}

}








// public void guardar(Map<String, String> producto) throws SQLException {
	public void guardar(Producto producto) throws SQLException {
//		String nombre = producto.get("nombre");
//		String descripcion = producto.get("descripcion");
//		Integer cantidad = Integer.valueOf(producto.get("cantidad"));

		ConnectionFactory factory = new ConnectionFactory();
		final Connection con = factory.recuperaConexion();
		try (con) {
			con.setAutoCommit(false);

			final PreparedStatement statement = con.prepareStatement(
					"Insert into productos(nombre, descripcion, cantidad) " + " values(?,?,?)",
					Statement.RETURN_GENERATED_KEYS);

			try (statement) {
				ejecutaRegistro(producto, statement);
				con.commit();
			} catch (Exception e) {
				con.rollback();
			}
		}

	}

	private void ejecutaRegistro(Producto producto, PreparedStatement statement) throws SQLException {

		statement.setString(1, producto.getNombre());
		statement.setString(2, producto.getDescripcion());
		statement.setInt(3, producto.getCantidad());

		statement.execute();

		// VERSION 9
		final ResultSet resultset = statement.getGeneratedKeys();
		try (resultset) {

			while (resultset.next()) {
				producto.setId(resultset.getInt(1));
				System.out.println(String.format("Fue insertado el producto %s",producto.toString()));
			}

		}

	}
	
	
	
	
	
	
	
							 DAO con INSERT del producto
							 

Entiendo tu duda y es bastante válida. La razón por la cual se utiliza una clase como ProductoController en lugar de llamar los métodos directamente desde ControlDeStockFrame tiene que ver con el principio de responsabilidad única en la programación orientada a objetos.

La clase ControlDeStockFrame probablemente está diseñada para manejar la interfaz de usuario y la interacción con el usuario. Si agregamos lógica de persistencia de datos (como guardar, eliminar, listar y modificar) directamente en esta clase, estaríamos mezclando responsabilidades. Esto puede hacer que el código sea más difícil de mantener y de entender.

Por otro lado, la clase ProductoController actúa como un intermediario entre la interfaz de usuario (ControlDeStockFrame) y la lógica de persistencia de datos (PersistenciaProducto). Esto permite que cada clase tenga una única responsabilidad, lo que hace que el código sea más modular y fácil de mantener.

Por ejemplo, si en el futuro necesitas cambiar la forma en que se guarda un producto, solo necesitarías modificar la clase PersistenciaProducto. La clase ControlDeStockFrame y ProductoController no necesitarían ser modificadas, ya que su responsabilidad es manejar la interacción con el usuario y coordinar las acciones entre la interfaz de usuario y la lógica de persistencia de datos, respectivamente.

Espero que esto aclare tu duda. Recuerda que estos son principios generales de diseño de software y pueden haber casos específicos donde se justifique una estructura de código diferente.

Espero haber ayudado y buenos estudios! Mucho éxito en todo lo que te propongas y si tienes alguna duda aquí estaremos para apoyarte.							 
							 
							 