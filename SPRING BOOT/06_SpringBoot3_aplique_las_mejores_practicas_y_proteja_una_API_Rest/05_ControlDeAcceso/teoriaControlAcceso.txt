




													02 Interceptando el Requests
													
Transcripción
[00:00] ¿Qué tal? Bienvenidos a su quinta clase de su curso de Spring Boot aplicando buenas prácticas y asegurando un API Rest. Hasta el momento lo que hemos visto es el proceso de autenticación, vamos hacer un pequeño resumen sobre eso primero.

[00:15] Usamos Insomnia para simular un cliente front-end, aplicación móvil cualquier cliente y enviamos un usuario, una clave, ya aprendimos cómo obtener estos parámetros, lo enviamos a nuestro API Rest.

[00:28] Y ya como estamos integrando con nuestra base de datos, ya con nuestro método login ya podemos generar nuestros usuarios, la clave siempre tenerla encriptada con el algoritmo BCrypt que es el que hemos elegido. Una vez que Spring encuentra este usuario en la base de datos, la base datos nos lo va a devolver, Spring va hacer la comparación si el usuario es de que hemos requerido o no.

[00:52] Vale la pena recalcar aquí que ese comportamiento es una autenticación del tipo stateless a diferencia de stateful, porque al inicio apenas instalamos Spring Security, ustedes también ya vieron que Spring por defecto ya nos crea una interfaz para hacer un login con un usuario y una clave.

[01:12] Entonces aplicando algunas modificaciones en el código, por ejemplo, implementando algunas interfaces propias de Spring, por ejemplo UserDetails, la interfaz UserDetails en nuestra clase usuario para indicarle que el usuario es un usuario de la autenticación de Spring, y uno una entidad cualquiera.

[01:31] Ya podemos indicarle también los campos, en fin, ustedes ya conocen mejor todas las mejoras y personalizaciones que hemos hecho para conseguir sobrescribir ese comportamiento y pasar de una autenticación stateful a stateless. ¿Qué más hemos visto?

[01:49] Hemos visto cómo generar nuestros propios JWT, JSON Web Token, aprendimos cómo agregar campos en nuestro token, generarnos una librería de Auth0 y finalmente devolver ese token a nuestro cliente.

[02:06] Por ejemplo, vamos a ver aquí en nuestro cliente. Aquí sí ya nos logueamos como “diego.rojas”, con mi clave, login, clave, no hay nada del otro mundo. El nos devuelve ese token. Y ahora la pregunta es ¿qué vamos a hacer con ese token? Por ejemplo, ¿recuerdan que iniciamos la clase anterior diciendo que esta no es una API pública? Porque es de una clínica.

[02:30] Por lo tanto mis recursos, mis recursos de médico todo eso deberían estar protegidos. Pero si yo sigo aquí enviado el request, vemos que siempre está obteniendo los datos, siempre está abierto. Entonces esto es lo que vamos a tratar de cerrar hoy día, vamos a bloquear todos nuestros requests para que acepten requests solo con un token válido.

[02:57] Si recuerdan la presentación anterior, esto ya sería el proceso de autorización. Recuerden el ejemplo que les platiqué. Autenticación es cuando tú válidas que tú eres quien dice ser, esto quiere decir que por ejemplo con tu documento de identidad, tú puedes probar que tú eres la persona que está en ese documento.

[03:20] En nuestro caso, con nuestro usuario y nuestra clave probamos que somos nosotros. Eso es lo que es la autenticación. Y autorización es qué tanto puedes hacer tú en esa aplicación. ¿Y cómo es que funciona esto? Viendo un poco más detalladamente, el token que acabamos de generar aquí en el cliente, tiene que ser enviado en el header o en los encabezados en las cabeceras de request, porque recuerden que request tiene headers y tiene body.

[03:48] Entonces en el header siempre todo request tiene que ir acompañado de un token válido. Recuerden que a nuestro token le hemos configurado un tiempo de expiración. Entonces si ese tipo de expiración aún no caduca, debería ser aceptado en nuestro request, solo en ese caso.

[04:07] Y bueno en el body es la información que enviamos normalmente. Del lado del API Rest, por ejemplo, si recibe un body con authentication, lo primero que va a hacer es validar el token, y si es que está validado liberamos acceso. Si no está validado entonces bloqueamos el request completamente y enviamos a un mensaje de Unauthorized por ejemplo, un 401 y ahí terminaría ese flujo.

[04:34] Viéndolo un poco más detallado técnicamente aquí, en la parte de Spring por ejemplo, si yo ya les mencioné que cada request tiene que venir con un token, y yo necesito interceptar ese token o ese request para poder evaluar, aquí yo podría hacerlo de dos formas, por ejemplo miren aquí. Este es mi lado del código.

[05:01] Y yo podría ponerle algo así como var token = obtenerToken algo así como esto, ahorita estamos escribiendo pseudocódigo, y yo puedo obtener el token y hacer un If (tokenValido) entonces, haz alguna cosa, pero recuerden que esto de aquí tendría que ir repetirse por cada método en mis otros controllers.

[05:40] Por ejemplo el médico controller, yo tendría que obtener el token aquí para retornar los datos del médico, lo mismo para eliminar médico y todos los métodos en todos los controllers. Esto de copiar y pegar código no es escalable y ya lo vimos con nuestro manejo de excepciones. ¿Qué hicimos en ese caso?

[05:58] Bueno, vinimos a crear nuestro paquete de errores en infra y construimos un tratador de errores, entonces pensando en esto quizás ahora ustedes piensen: “Okay, ¿por qué no implementar filtros?” Si ustedes han llevado ya el curso de Java Servlet, quizás ya son familiares con los filtros y saben que con un filtro pueden interceptar el request antes que llegue a controller y modificar algunos datos, hacer algunas validaciones. Y es el flujo ideal, digamos.

[06:29] Por ejemplo el request va entrando aquí, tienes tus filtros, entran al DispatcherServlet, que es el Servlet de Spring que hace digamos el redirect al controller correcto y bueno, tenemos otros interceptores, que son los handler interceptors, hasta que llega al controller.

[06:47] Esto de aquí es implementación propia de Spring. Esto es lo que sucede dentro de Spring y esto es lo que tú puedes implementar. Entonces puedes implementar al nivel que incluso antes que Spring actúe, tú ya puedes implementar tus propios filtros y modificar el request o hacer la validación hasta que llega a tu controller o quizás ni siquiera llega al controller porque lo rechazas en este nivel.

[07:10] Eso es lo que vamos a ver en esta parte del curso. Es el proceso de autorización de los requests. Nos vemos en el siguiente video.





													
													04 Creando el Security Filter
													
Transcripción
[00:00] Bien. Entonces vamos ya a la parte interesante que es el código. Venimos aquí y ya hemos dicho que lo que vamos a implementar son filtros para conseguir interceptar nuestro request y hacer la lógica de validación del token.

[00:16] ¿Qué es lo primero que tenemos que hacer? Crear el filtro. Entonces vamos a nuestro paquete de infra y aquí en security vamos a darle clic derecho y vamos a crear un nuevo filtro llamado SecurityFilter.

[00:33] Es una clase y bueno, si yo quiero que esta clase sea reconocida por Spring al momento en que la escanee, entonces yo debo usar una anotación. Y ahora la pregunta es para ti. ¿Qué anotación debería usar? Porque esto no es un servicio, no es un repositorio y tampoco es un Controller. Aquí la notación que tendría más sentido component.

[01:05] Component es el estereotipo más genérico de Spring para definir simplemente un componente de Spring. Spring precisa hacer el escaneo en la clase para incluirlo en su contexto. Service, repository y controller son estereotipos basados en componente, explicándolo en otras formas.

[01:24] En Spring todo podría ser Component. Tú podrías nombrar Component una clase de servicio, todo eso, pero para fines de implementar la lectura el código, para un programador Spring divide componente en varios estereotipos para especificar Okay, es un componente pero un tipo en específico.

[01:43] Esto ya es un poco más sobre Springs Corp. cómo funciona pero es muy bueno que lo sepan, dado que nuestro filtro no es un servicio ni un repositorio ni nada, vamos a dejarlo como Component. Entonces paso número 2, si tú ya has visto cómo funciona un filtro, quizás me digas: “Okay, Diego, entonces vamos a extender de filter”.

[02:11] No este filter, de Java.xml y bueno, así puede ser, pero nosotros no vamos a usar un filtro directamente de Java, porque estamos usando Spring y Spring ya nos da ciertas funcionalidades, ciertos métodos para que nuestro proceso de validación sea un poco más tranquilo, no tengo que modificar tanto.

[02:34] Para esto entonces yo voy a extender de OncePerRequestFilter, pero yo no puedo extender de OncePerRequestFilter porque es una interfaz, entonces lo que yo voy a hacer aquí es implementar. Y me está dando un error de compilación porque no está implementado método, lo que voy a hacer aquí ya es implement methods, que es un solo método llamado doFilter.

[03:02] En doFilter vemos que recibe tres parámetros. Tienes el filterChain, el response y el request, esto de aquí debe ser conocido para ti si eres familiar con Servlet y filters. Pero bueno, ahora ya tenemos nuestro método doFilter y yo quiero saber primero que todo si este filtro funciona.

[03:25] Entonces yo quiero saber si este filtro funciona. Quiero ver acá. Es una clase abstracta, por eso es que se extiende. Yo estaba en la duda si era una interfaz, pero bueno, si quiero saber si funciona lo que voy a hacer aquí es imprimir algo. Voy a decir “El filtro está siendo llamado”.

[03:51] Porque se supone que ya lo implementé. Spring ya lo está escaneando, por lo tanto este filtro debería ser llamado si es que yo entro de un request. Vamos a poner a prueba eso, esperamos a que reinicie mi servidor. Ya debería reiniciar. Quizás ya reinició.

[04:12] Entonces venimos nuevamente a Insomnia, listamos los médicos, enviamos y recibimos un 200 OK y todo muy bien. Pero quiero ver si mi filtro ha sido llamado y no está siendo llamado aún. Voy a detener mi servidor un momento porque no he visto que haya hecho el refresh necesario. Esperamos un poquito.

[04:42] Me está dando, por el pseudocódigo que habíamos escrito y no lo hemos borrado, tiene todo sentido, no estaba comprando mi código. Ahora voy a iniciarlo sin errores. Vemos que inicia mi servicio, inicio de aplicación y vamos a probar el filtro.

[05:10] Le damos enviar y aquí hay dos cosas. La primera me retorna OK, o sea, el request fue excelente, pero ya no recibo nada. ¿Dónde están mis médicos? ¿Dónde está mi lista de médicos? OK. Aquí ya entra la parte aquí el filtro está siendo llamado. Tres veces porque yo clilqueé tres veces, pero esto es bueno porque al menos mi filtro, mi securityFilter ya está siendo usado.

[05:35] Mi securityFilter ya está siendo llamado .Entonces en este momento yo ya puedo hacer la validación del token, pero vamos por partes porque hemos visto que ya no está retornando mis recursos que yo tenía guardados de médico. ¿Esto por qué? Vamos a ver nuestro diseño y en los filtros, si el filtro ejecuta alguna acción, tiene que llamar, sí o sí tiene que llamar al siguiente filtro que va a ser el handling, que va a atrapar este request.

[06:08] Si el filtro no llama al siguiente filtro, es decir si él no hace esa transferencia directamente a la cadena de filtros, recuerden esta definición, cadena de filtros filterChain, si el filtro no hace esa transferencia al siguiente filtro entonces no se devuelve nada, porque todo queda a nivel del filtro.

[06:30] Entonces el filtro necesita saber qué es lo que va a filtrar. Si tú no especificas qué es lo que va a filtrar y a dónde lo va a mandar el filtro dice OK, request fue excelente, te devuelvo tu 200 pero no te devuelvo el recurso porque no llegas a esta parte de aquí, no llegas a controller. El controller ni siquiera es llamado en este momento, porque el filtro ya lo intercepta.

[06:53] La única forma que tú tienes de hacer eso es usando el parámetro FilterChain, es por eso que les comenté que recuerden eso, el concepto entre filtros, la cadena de filtros, la cadena consiste en que el filtro debe pasarle el request al siguiente, si no, no sucede nada.

[07:12] Para eso lo que yo voy a hacer aquí es comenzar a decirle filterChain.doFilter y tengo aquí mi request y mi response. Esto ya llega de los parámetros aquí. ¿Qué es lo que yo quiero decir con esto? Le digo: “filtro, ejecuta tu magia, ejecuta tu filtro, fíltrame esto, y mándale el request y el response que están llegando del método HTML.” Guardamos aquí.

[07:46] Esperemos un momento que reinicie mi servidor y vamos a ver si es que ahora ya está funcionando como debería. Ya reinició el servidor, enviamos nuestro request y listo, ya tenemos nuevamente nuestros recursos y nuestro filtro ya está siendo llamado.

[08:06] Y observen, al inicio, yo solo tenía los tres mensajes de que filtro es llamado y ningún mensaje de Hyibernate, porque como les expliqué antes, no llega, ya este request no llega ni siquiera al Controller si es que el filtro lo hace el doFilter. Esta es la única forma de hacer el filtro, recuerden esto.

[08:27] Si el filtro no llama específicamente al siguiente, no va a suceder y ya está el query de Hybernate. Entonces ya tenemos digamos que el 20% del trabajo listo. Tenemos el filtro, estamos interceptando el request, esto yo lo voy a borrar porque ya sé que está funcionando y también tengo finalmente la llamada al siguiente filtro. Vamos a ver más detalles de implementación en el siguiente video. Nos vemos.







													05 Obteniendo el Token #1
													
Transcripción
[00:00] Bien, ya tenemos la primera parte completa, ya tenemos nuestro filtro implementado y ya estamos pasando el request al siguiente nivel para el Controller. ¿Qué es lo que sigue? Exacto. Lo que sigue en nuestro flujo de autorización, ya estamos aquí, ahora lo que vamos a hacer es validar el token.

[00:19] ¿Cómo lo vamos a hacer? Venimos aquí y tenemos que ver principalmente dos cosas. La primera, yo aquí tengo que obtener el token, y esto lo voy a obtener de los headers. ¿Cómo es que esto va a llegar? Observen, por ejemplo, aquí en mi cliente, que es Insomnia, yo tengo aquí una pestaña de autenticación que es esta de acá.

[00:43] Si voy a mi registrar médicos también, por ejemplo, tienen Auth, en actualizar tienen Auth, y esto es para los tipos de autenticación que podemos implementar, por ejemplo, en mi listado yo puedo elegir entre tener no autenticación, tenerlo libre, completamente vacío, o también puedo implementar un API security key, para hacer la autenticación o OAuth, usar Bearer Token, que es nuestro caso.

[01:11] Y automáticamente pues Insomnia me va a proveer un campo para el token y un campo para el prefijo. El prefijo lo vamos a ver un momento, todavía no se preocupen, vamos a comenzar por el token. Primero necesito generar otro toquen válido porque este token lo he generado hace unos días, voy a darle enviar otra vez y ya me genera otro token. Voy a copiar este token aquí.

[01:35] Le damos "Ctrl + C", venimos a nuestro listado y aquí yo le voy a decir “Mándame el token en el header” y prefijo lo voy a dejar vacío por ahora. Van a ver qué se trata de este parámetro en un momento más. Volvemos al código y ahora tengo que obtener el token que estoy enviando aquí que va a llegar en un header. Tengo que ir obtenerlo aquí.

[01:59] Si voy a la parte de headers, puedes ver que yo no estoy agregando ningún header personalizado, entonces vamos a ver cómo lo puedo hacer. Normalmente por standard el token llega en un header específico, que es authorization. El nombre del header, donde llega el token JTW es authorization.

[02:29] Entonces lo que vamos a hacer aquí es este request.getHeader, es un método. Esto me va a decir cómo se llama el header, se llama “Authorization” que es autorización en inglés, punto y coma, y aquí yo quiero imprimir el token, para ver si es que estoy logrando obtener el token que yo quiero.

[02:52] Entonces este es mi primer paso, hacer un request.getHeaderAuthorization e imprimir el token y después sigue la vida y pasamos al siguiente filtro, vamos a ver si funciona, vamos a guardar primero. Vemos que ya reinició, perfecto. Enviamos, vemos qué pasó, vemos aquí a headers, no vemos ningún header en la respuesta.

[03:16] Vamos aquí, vemos que se sucedió el query y observen acá. Observen este token de aquí. Es el mismo token que hemos enviado aquí en nuestro header de autorización, authorization, ya estamos con esto, pero miren el prefijo que hay aquí: el bearer.

[03:36] Este bearer viene a ser el prefijo que por defecto en el estándar ya está especificado así. Por estándar este token siempre va a tener el prefijo bearer y después va a seguir el token. Entonces como yo solamente quiero trabajar con mi token, lo que voy a hacer aquí es .replace y le voy a decir que yo quiero reemplazar “Bearer” más el espacio, coma, por vacío.

[04:10] Entonces mi token lo que va hacer es retornar el header de autorización y reemplazar el parámetro “Bearer” por nada, por vacío. Entonces lo único que me va a retornar es mi token en sí, mi token específico y es lo único que yo necesito para esto. Entonces, vamos a ver si aquí reinicio mi servidor. Voy a enviar otra vez el request.

[04:33] Voy a ver aquí y listo está funcionando. Yo tengo esto aquí. Por ejemplo, nuevamente recuerden el nombre del header en específico, es authorization. Si yo pongo por ejemplo authorizations o cualquier cosa, esto me va a dar un error, me va a dar una excepción, porque va a lanzar un null pointer exception. Es lo más probable.

[04:55] Vamos a probar aquí. Enviamos otra vez. Me dio un 500. ¿Por qué? Porque simplemente este header no existe, el estándar ya te dice que es authorization en singular, y ese es el nombre, a no ser que por reglas del negocio hayan definido, que el nombre va a ser diferente, pero eso ya sería una mala práctica porque estarían yendo en contra del estándar.

[05:20] Entonces, sin más, ya tenemos el token, ya tenemos la primera parte. Miren, tenemos el token. Estamos obteniendo el header de autorización y estamos reemplazando la parte Bearer, el prefijo “Bearer” por vacío para obtener el token en sí. ¿Qué es lo que sigue? ¿Qué tenemos que hacer? Tenemos que comenzar a evaluar si el token es válido, no es válido, si es este usuario, si no es de este usuario.

[05:43] Entonces quédense aquí. Quizás es un poquito complicado al inicio, no se preocupen. Esto es hasta un poco más simple que nuestro proceso de autenticación. Entonces nos vemos en el siguiente video para implementar ya la validación en sí.





													06 Obteniendo el Token #2
													
Transcripción
[00:00] Lo que sigue es tratar de hacer un handling a esa excepción que estamos recibiendo. ¿Cómo? Porque por ejemplo ya vimos que si el header no llega, me va a lanzar un null pointer exception. ¿Pero qué pasaría si el token es incorrecto o viene un string vacío o viene cualquier cosa?

[00:18] Entonces lo que yo voy a hacer aquí es hacer antes del replace, porque aquí si yo hago un replace a algo vacío todo me puede dar una excepción. Entonces voy a comentar esto aquí primero, punto y coma, porque lo que voy a hacer aquí, es que si el token es igual a vacío, entonces voy a hacer un throw new RuntimeException.

[00:50] Y listo. Y voy a poner aquí “El token enviado no es valido”. Y listo. El token está vacío. O si token está nulo. Entonces ahora voy a preguntar aquí, if token null o está vacío, entonces voy a lanzar un new RuntimeException. Y solamente si ya no llegó a esta línea voy a hacer el reemplazo de aquí: token = token.replace. Y listo.

[01:34] Con esto ya tenemos nuestra implementación ya saneada. Vamos solamente a probar, vamos a guardar. Limpiamos, corremos nuestro servidor. Siempre demora un poco en mi máquina pero listo, ya está. Vamos a limpiar y tenemos nuestra respuesta OK, y ya está todo funcionando correctamente y estamos imprimiendo el código como debe ser.

[02:03] Entonces siempre recuerden hacer el código fault tolerant como se le dice, pensando siempre en los corner cases que pueden suceder, si estuviéramos trabajando con TDD por ejemplo sería muy fácil escribir nuestros tests, nuestros casos de uso cuando un token llega vacío, cuando llega null, y ya tendríamos cubiertos estos escenarios que pueden suceder potencialmente y no como ahora que lo hemos visto cuando sucedió recién en el momento de la implementación del código.

[02:34] Es un aconsejo. ¿Qué es lo que falta ahora? Bueno, como vimos que yo al token le puedo mandar datos de expiración, datos de quién lo está firmando y datos de quién está asignado a ese token, ahora lo que yo necesito hacer es la parte de validar si el token es válido, valga la redundancia, para liberar el acceso o bloquear el request, porque lo que yo puedo hacer aquí después preguntar algo así como if tokenEsValido, entonces yo puedo llamar aquí a filterChain.doFilter.

[03:16] Y si no, no hacer nada y simplemente el request va a quedar ahí. Eso vamos a ver en el siguiente video. Nos vemos.




													07 Validando el Token
													
Transcripción
[00:00] Listo. Ya estamos en la parte de validar si nuestro toquen aún no está expirado y si está asignado al usuario que ha iniciado sesión. Entonces vamos por partes para esta implementación. Lo primero que tenemos que hacer es venir a nuestro tokenService. Y si yo ya tengo un método para generar mi token ahora yo debería tener un método para digamos consumir el token y validarlo.

[00:27] Voy a creer aquí un método llamado public. Este va a devolver un String getSubject. Entonces el subject, recuerden, es a quién este token está siendo asignado, para quién este token ha sido generado y con eso lo que yo voy a hacer es obtener este nombre de usuario y validar si en efecto el usuario ha iniciado o no ha iniciado sesión en mi sistema.

[00:54] Recuerden que esta es un API, por lo tanto nuestra autenticación fue en stateless y no stateful, pero vamos a ver eso en un momento más. Primero vamos a obtener el subject. ¿Cómo lo hago? Bueno de la misma forma que hicimos con el método para crear nuestro JWT, vamos a inspirarnos en este ejemplo para verificar un JSON Web Token.

[01:17] Entonces lo que vamos a hacer es copiar esta parte del código. No vamos a copiar esto porque el token lo vamos a recibir como parámetro y lo voy a especificar aquí, string token, y pego el código. Ahora lo que tengo que hacer es hacer algunas actualizaciones como por ejemplo, enviarle el tipo de algoritmo correcto que es este de aquí.

[01:45] Y también mi apiSecret, y recuerden, tiene que ser el mismo porque si no es el mismo simplemente esta firma de token no va a coincidir y mi proceso de verificación va a ser rechazado. ¿Cómo funciona? Vamos a borrar esto solo un momento. El issue también tengo que verificarlo por “voll med” y aquí al último le voy a dar un .verify, y lo que va a verificar es mi token. Y con esto ya sería todo.

[02:22] Me está dando un error de compilación porque esto necesita, vamos a ignorar esto, necesita un tipo de verificación que yo no había importado aquí, pero no se preocupen. Vamos a importar también esta excepción y listo, vamos a usar esta que ya está generada y ya está. Tenemos todo en todo en orden para verificar nuestro token.

[02:57] ¿Qué más necesitamos? Aquí lo que yo voy a hacer es hacer un return, porque lo que tengo que hacer ahora es obtener el subject, entonces aquí voy a ponerle punto, getSubject y este verifier yo lo voy a return, verifyer.getSubject(), ahora sí. Perfecto.

[03:41] Vieron, lo que hice fue llevar verifier a una parte afuera del try catch, de forma que una vez que yo lo verifico, verifico el token y voy a retornar el subject de mi proceso de verificación. Vamos a aplicarle una validación, que podría ser tranquilamente esta de aquí o también podemos hacerlo con if, que sería mucho mejor en este caso, porque no estamos escribiendo una prueba unitaria.

[04:11] Entonces podemos decirle que if verifier.getSubject = null. ¿Qué vamos a hacer? Vamos a hacer un throw new RuntimeException, con el mensaje “Verifier invalido”. Y si no bueno, retornamos verifier.getSubject, y listo, ya tenemos nuestro método getSubject.

[04:39] Ahora vámonos a nuestro securityFilter porque tenemos que llamarlo ahora, esto está en el tokenService. Yo lo quiero en securityFilter. ¿Qué es lo que tengo que hacer? Exacto, vamos a comenzar declarándolo. Entonces venimos aquí a SecurityFilter, vengo por acá y voy a decirle private TokenServide con @Autowired, como ustedes ya conocen.

[05:04] Recuerden. Siempre es mejor a nivel de un constructor, en este caso lo estamos haciendo por temas didácticos y la rapidez a nivel del campo, del field, pero no es la idea y aquí es donde vamos a preguntarle por el subject, porque lo que tenemos que hacer es verificar que en efecto ese subject es un usuario que está logueado en mi sistema.

[05:31] Primero que todo voy a hacerle un System.out, para imprimir mi TokenService.getSubject enviándole como parámetro el token y esto debería pues devolverme el subject de mi token. Entonces voy a limpiar todo esto para ver si es que funciona. Esperamos a que cargue.

[05:56] Vemos que ya inició y vamos a tarde enviar. Mi request nuevamente 200 Okay, nada en especial. Venimos a la consola para ver y observen, en efecto, ahora estoy recibiendo mi token que lo estoy imprimiendo aquí y ya tengo al subject del token. ¿Qué quiere decir esto? Ya estoy pasando por el proceso de consumir mi librería de Auth0 para descifrar el token, primero que todo validando la firma, validando la firma del token.

[06:34] Porque si falla en ese nivel me va a lanzar una excepción. Entonces nuevamente tenemos que lograr este exception. Exception.toString, para enterarnos si pasó algo. Va a validar que el issuer, que el emisor de este token sea “voll med” si no también nos va a dar un error.

[06:55] Va a hacer un build de este objeto verifier, y va a verificar nuestro token. Finalmente, ¿qué hacemos? Le damos un verifier.getSubject y con esto vamos a retornar, vamos a validar, si en efecto el subject es válido o no. Ahora, ¿cuál es la pregunta en este momento? Tengo mi SecurityFilter y aquí lo que yo quiero saber es ¿este usuario tiene sesión?

[07:26] Porque como tengo una autenticación del tipo stateless, yo no tengo nada que medir en la memoria, si este usuario ya está logueado o no. Eso ya lo vamos a implementar en el siguiente video. Nos vemos.






													10 Liberando el Acceso login #1
													
Transcripción
[00:00] Ya tenemos nuestro flujo de autorización completo, pero hay algunas cosas que aún necesitamos implementar aquí para que no solo sea completo, sino que sea óptimo y esté bien hecho, porque hay algunos casos de uso que se nos están escapando y los vamos a ver ahora.

[00:15] Por ejemplo, ella siendo un pequeño recap ya hemos visto cómo obtener el subject, estamos validando la firma del token, que estamos recibiendo, el header. Estamos validando el issuer, verificamos el token en sí y al final si el token es inválido retornamos alguna excepción y ahí terminaría todo nuestro proceso hasta ahora.

[00:37] Entonces si venimos a nuestra recolección de request, aquí, por ejemplo, yo le voy a dar send. Vemos que estoy recibiendo la información solicitada a mis recursos porque yo estoy enviando mi token de autorización aquí en header. Entonces funciona bien mi caso de uso en este caso.

[00:58] Si quiero por ejemplo obtener datos médicos yo no tengo ningún tipo de autenticación configurado, por lo tanto me debería dar error, vamos a ver aquí y en efecto miren aquí, me dio 500 internal server error, porque lo que él hace es un throw new runtime exception, y miren, el token enviado no es válido.

[01:17] Entonces está validando que mi token no está siendo enviado y eso es bueno, eso es lo que yo quería, ese era el objetivo principal, pero ahora miren aquí a login. En login estamos obteniendo el token aquí, pero si yo quiero generar ahora otro token, miren el error que me da.

[01:37] Ahora también me dice que el token no es válido y aquí sí estamos en un grave error, porque login tiene que ser abierto para todo mundo, de lo contrario es completamente imposible generar autorization tokens. Entonces eso es lo primero que vamos a arreglar ahora en esta parte. Para eso vamos a nuestro SecurityConfigurations.

[01:57] Y aquí en nuestro security FilterChain. Ya sabemos que aquí nosotros le decimos a Spring, le indicamos Springs el tipo de sesión. Y ahora lo que necesitamos es decirle que queremos autorizar los requests que tengan el siguiente matching por ejemplo los requests que lleguen con HttpMethod, get no, yo quiero un post.

[02:33] Y los requests que comiencen con login. Este va hacer el pattern, el patrón que va a seguir. Con eso le estoy diciendo que los requests hagan match con que tiene que ser un post y que sea login. Y también lo que yo quiero es que aquí le permita todo, entonces le doy un .permitAll().

[02:56] Entonces ahí con esto yo ya debería haber abierto mi login para todo mundo porque yo estoy diciendo que si también en mi request matchers, si viene un método que es un post y va a login, entonces permitirle a todos. De lo contrario y aquí viene otro, anyRequest .authenticated.

[03:21] Entonces, ¿cómo se lee esto? Esto se lee como decirle Spring, la política de creación es stateless y cada request que haga match que es un request de tipo post y va para login permitirle a todos. Después todos los requests tienen que ser autenticados. Y bueno, construye el objeto finalmente.

[03:46] Entonces esta es la forma, como le podemos decir a Spring: “abre este recurso para que sea público para todo mundo”. Vamos a probar si está funcionando. Entonces limpiamos, esperamos un momento, vemos que ya recargó. Listo. Y vamos a intentar otra vez. Le vamos a dar send y me va a dar un 403 forbidden, vemos que ya no me da la excepción, pero ahora me está diciendo que no tengo acceso a este recurso.

[04:18] Entonces vamos a investigar por qué. ¿Qué es lo que me dice aquí el error de Spring? Lo que él me dice el token enviado no es válido, o sea, estamos aún cayendo en el error de validación del token de Spring, pero ahora tú me preguntas: “Diego, pero se supone que estamos permitiendo eso”.

[04:36] El problema está exactamente en cómo estamos manejando eso con los filtros, porque en nuestro filter, si vemos aquí entonces si no recibe esto simplemente no lo toma como válido. Tenemos que indicarle aquí que el usuario que ha enviado ese token en realidad es válido. Para login debería ser abierto, simplemente abierto para todos los requests que quiera hacer. Entonces vamos a ver ese problema ahora.





													11 Liberando el Acceso login #2
													
Transcripción
[00:00] Porque vamos a la lógica. Aquí vamos a leer un poco lo que estamos haciendo. ¿Qué hacemos aquí? Primero obtenemos el header y después le preguntamos si el token es nulo o está vacío, que me lance esta excepción y es aquí donde estamos teniendo el error, porque este filtro se está ejecutando de todas formas.

[00:19] Porque el filtro de Spring fue el primero y ya lo dejó pasar, ahora mi filtro está siendo ejecutado y como yo valido que token no sea ni nulo ni vacío, entonces yo mando esto, este error. ¿Cómo puedo solucionarlo? Voy a invertir el orden en el que yo estoy haciendo cosas. ¿A qué me refiero con invertir?

[00:42] En lugar de preguntar si el token está nulo o vacío, lo que yo le voy a decir es que si el token, if token no está nulo entonces ahí va a ejecutar esta lógica y eso lo voy a borrar. Porque si este header no existe entonces esto va a ser nulo. Si el token no está nulo, entonces recién ahí en lugar de validar, si es que es igual a nulo, yo voy a validar que no sea nulo.

[01:16] Porque solo ahí yo voy a hacer este proceso de activar el filtro, de lo contrario, no voy a hacer nada. Vamos a ver si funciona esta implementación, vemos que ya está recargando. Recargó. Entonces venimos otra vez, enviamos a Insomnia y tenemos 200 OK.

[01:42] ¿Pero por qué no pasa? Porque no estamos haciendo el filterChain.doFilter. Entonces venimos aquí le ponemos aquí el filterChain. Esperamos que recargue un momento más. Listo. Enviamos y ya está funcionando para mi login, vemos que ya está abierto. ¿Pero qué pasará con este de aquí? Vemos que ya está prohibido.

[02:10] Porque no estoy enviando ningún token. Entonces con esto yo tengo mi login completamente abierto para cualquier request y mis demás métodos completamente forbidden. En este caso, como yo tengo el token, le voy a enviar y también me está dando forbidden.

[02:28] Entonces ahora yo tengo otro problema diferente, porque yo estoy enviando un token válido. Incluso lo que yo voy a hacer aquí es enviar en este nuevo talking que me ha devuelto yo voy a reemplazar aquí en mi listado. Vengo aquí, lo enviamos y de todas formas por más que estoy enviando un token válido, me dice que está prohibido. Y esto no está bien.

[02:52] Este es un error que estamos cometiendo. Entonces vamos al código nuevamente para saber en dónde es que está fallando. Si se fijan bien, logró hacer la query contra la base de datos. Entonces vamos a ver en qué parte es que está fallando en el TokenService, porque en la validación hay alguna cosa que no está bien hecha.

[03:14] Vamos a dar el código. Dice valida apiSecret con este issuer y verifícalo. Aquí le voy a decir getSubject. ¿Pero qué pasaría si el token no llega? Yo no valido si el token llega nulo o no. Entonces lo que yo voy a ver ahora es decirle que si el token es null, ahí yo voy a darle un throw new RuntimeException().

[03:52] Ya estoy validando primero que todo que mi token no llegue nulo. De esa forma yo me aseguro que subject no va a dar un error aquí en este punto porque yo lo estoy haciendo ya a nivel del token en sí. Eso es lo primero que quiero validar, para aplicar aquí vemos que ya recargó, voy a limpiar mi terminal y voy a enviar otra vez y vemos que me sigue retornando forbidden.

[04:16] ¿Esto por qué es? Vamos a ver aquí. Me dice que ya completó la inicialización. ¿Qué más tengo en este código? Venimos por aquí, en el securityFilter está recibiendo authorization, el token no está viniendo nulo porque yo estoy consiguiendo generar. Solo para eso yo voy a darle aquí un sout, un System.out.print, para validar.

[04:40] Validamos que token no es null. De esta forma si es que entra aquí, sabemos que el token no va a ser null. Entonces vamos a ver qué nos imprime, vemos que recargó mi servidor. Enviamos. Validamos digamos aquí y vemos que no está llegando aquí. Entonces, eso ya nos está dando un primer síntoma. ¿Por qué?

[05:04] Si yo vengo aquí, voy a decirle que “este es el inicio del filter”. Le damos salvar. Esperamos que recargue, vemos que recargó, enviamos y tampoco está siendo llamado. Vamos a hacer otra cosa porque lo que sucede es que mi filtro en este caso ya no está siendo llamado en absoluto porque ya no está imprimiendo ninguno de los valores que yo deseo que imprima aquí. Voy a tener mi servidor.

[05:46] Voy a iniciarlo otra vez en caso de ser algún problema de catching, porque de lo contrario en alguna parte yo estoy ejecutando mal mi código aquí. Entonces voy a retornar aquí y en efecto no está funcionando. Me dice que inicializó y todo eso pero no me retorna ningún tipo de error ni nada de eso.

[06:09] ¿Qué hacemos en estos casos cuando el error no está claro? Damos un paso hacia atrás, volvemos al filter y le vamos a preguntar que me imprima el token nuevamente. Voy a darle un sout. Imprime el token, guardamos.

[06:35] Ejecutamos, no me imprime nada aún, voy a probar otra vez con login. Voy a enviar. En efecto, me dice el inicio del filter el token es null. Entonces pasó por mi filtro, perfecto, y ya está. Entonces, ¿cuál es aquí el detalle? ¿Qué es lo que está sucediendo? Eso lo vamos a explorar en el próximo video.






													12 Probando el Control acceso
													
Transcripción
[00:00] Bien, vamos a volver a ver este gráfico para entender un poco qué es lo que está sucediendo. Recuerden acerca de los filtros, los filtros de Java son llamados y después los de Spring subsecuentemente y entran al dispatcherServlet de Spring y los filtros que implementamos ahí hacen el filtrado correspondiente valga la redundancia, para mandarlo al Controller. ¿Qué es lo que está pasando aquí?

[00:26] Como podemos ver, por más que yo estoy enviando requests con token válido, yo estoy obtenido un error forbidden, pero mi filtro ni siquiera está haciendo llamado. ¿Esto qué quiere decir? El filtro de Spring en esta instancia porque recuerden que mi filtro, el filtro que hemos implementado extiende de OncePerRequestFilter, que es propio de Spring.

[00:52] Entonces por lo tanto necesito decirle a Spring: “Sprint, antes de llamar a tu filtro, llama a mi filtro”. Porque lo que está sucediendo es que como yo ya configuré aquí, este filtro está siendo llamado antes que el que yo he implementado.

[01:10] Y por lo tanto está bloqueando todos mis requests, porque él solamente valida: “Okay, este método está abierto”. Listo, está abierto, pero todos los demás están cerrados, porque no tiene cómo validar una logia, que yo estoy usando aquí en mi propio filtro que he creado.

[01:26] ¿Qué es lo que tengo que hacer para eso? Tengo que encontrar una forma de decirle que agregue mi filtro primero antes que el filtro de Spring por defecto. ¿Spring es tan personalizable que me permitirá hacer eso? Pues claro, obvio, y lo vamos a hacer ahora para permitir estos requests. ¿Cómo?

[01:49] Con un ejemplo aquí después de anyRequest, lo que yo le voy a decir es que me agregue un filter, aquí no porque estamos ante authenticated. Al final. Y lo que yo le voy a decir es qué también, .and(), .addFilterBefore. ¿Qué filtro quiero agregar antes? Quiero agregar mi SecurityFilter, pero yo necesito una instancia de mi SecurityFilter.

[02:28] Entonces lo que voy a hacer es, como ustedes ya saben, private, llamo a mi SecurityFilter. Teniendo en cuenta que este med.voll.api mi SecurityFilter. Como es un componente lo voy a inyectar, le voy a decir @Autowired, y esta instancia yo se la voy a meter aquí.

[02:50] Y listo, entonces aquí mi .addFilterBefore(securityFilter) y también un tipo de autenticación, que es UsernamePasswordAuthenticationFilter.class. Y esto acá les puede sonar un poco extraño al inicio. Esto es porque este tipo de filtro UsernamePasswordAuthenticationFilter lo que va a hacer es validar que en efecto el usuario que está iniciando la sesión existe y que ya está autenticado.

[03:20] Esto posiblemente nos lance otro error, por ejemplo aquí ya en compilación ya vemos que no necesitamos otro and, entonces lo borramos y lo dejamos en build. Vamos a guardar. Esperamos un momento. Como pueden ver, aquí lo que yo hice fue decirle explícitamente “agrega un filtro antes aquí, porque yo voy a implementar UsernamePasswordAuthenticationFilter en mi SecurityFilter.”

[03:52] Venimos aquí, enviamos, vemos que sigue prohibido y login sigue funcionando. ¿Entonces qué es lo que tengo que hacer ahora? Como estoy usando UsernamePasswordAuthenticationFilter, este método de aquí, esta clase, lo que hace es validar que mi usuario en sí tiene una sesión iniciada en mi sistema, en mi API, pero recuerden que tenemos un tipo de sesión stateless.

[04:21] ¿Cómo tú puedes forzar un login de usuario por cada request? Exacto, lo que vamos a hacer aquí en el filtro ahora es que si el token no es nulo, reemplazamos por “Bearer”, obtenemos el subject del token. Entonces aquí vamos a hacer un pequeño refactor, porque lo que yo le voy a decir, es que la variable subject va a ser igual a TokenService.getSubject, yo voy a borrar estas dos líneas porque ya no las necesitamos.

[04:56] Vamos a mantener nuestro código limpio, borramos esta de aquí y borro esto de aquí. Y si subject no llega nulo if subject no es nulo, eso ya me dice que es válido. Si subject no llega a nulo es que el token ya está válido. Token valido. Perfecto. ¿Qué es lo que sigue?

[05:26] Si es token válido, por lo tanto ahora yo lo que quiero hacer es forzar un inicio de sesión en mi sistema. ¿Esto cómo lo hago? Voy a venir aquí y le voy a decir private UserRepository. No es este de aquí. Es UsuarioRepository, como ustedes ya deben saber @Autowired y aquí lo que yo le voy a decir es que usuario = usuarioRepository.FindByLogin y aquí lo que yo le voy a mandar es el subject.

[06:19] Entonces con esto él ya debería ser capaz de retornar mi usuario por login y hacer el llamado al método para que inicie sesión en este momento. Vamos a ver. Lo que tengo que hacer ahora primero es invocar a una clase de Spring SecurityContextHolder y aquí lo que voy decir es getContext.

[06:49] Del contexto de seguridad que tiene en este momento Spring, yo le quiero decir setAuthentication, y este Authentication va a ser mi usuario. De la misma forma en la que lo hicimos anteriormente le voy a mandar mi usuario como mi objeto de autenticación que yo deseo usar. Pero vemos que el usuario no está compilando. ¿Por qué?

[07:12] Porque yo necesito transformar este usuario en un objeto de authentication entonces lo que yo hago ahora es decirle que authentication es una variable que yo voy a crear aquí y aquí es donde va a suceder toda la magia, porque authentication no es un var. Venimos aquí var authentication = usernamePasswordAuthenticationToken.

[07:42] Esto va a recibir, ustedes ya conocen esto. Esto es un new. Ustedes ya han visto esto. Es el usuario. ¿Qué más va a recibir? No va a tener las credenciales porque no están generadas y aquí también va a tener el usuario., porque yo ya tengo el objeto en la base de datos usuario.getAuthorities().

[08:06] Voy a darle un salto de línea aquí para que quede más legible, punto y coma al final y con esto yo ya le estoy diciendo a Spring mi siguiente lógica. Le estoy diciendo que si el token no llega nulo, por ejemplo, primero que todo yo quiero el header authorization si no es nulo, entonces voy a hacer un replace, para que quede un poco más legible lo que yo voy a poner aquí.

[08:30] Voy a reemplazar esta variable diciéndole que este va a ser el authHeader. Si el authHeader no es nulo, entonces token y voy a declarar aquí var token. Entonces si no llega nulo, reemplazamos el authHeader y eso sería el token, el authorization token. Obtenemos el subject y preguntamos nuevamente si el subject no es nulo, el token está válido y con esto encontramos al usuario.

[09:08] Con estas dos líneas le decimos a Spring: “este login es válido para mí” porque yo estoy autenticando este usuario ahora con mi request y yo te estoy verificando que el usuario existe. Entonces yo estoy acá forzando, forzamos inicio de sesión.

[09:29] Ahora, que forzamos ese inicio de sesión lo que hacemos es, en el SecurityContext de Spring, vamos a setear manualmente esa autenticación, de modo que sí venimos aquí, miren, a mi configuración ya para los demás requests el usuario ya va a estar autenticado.

[09:51] Okay vamos a probar ahora nuestro código. Vamos a nuestro listado de médicos, enviamos. Y miren cómo está ahora. Ya está recibiendo los datos porque está forzando una autenticación de usuario.

[10:06] En el delete, por ejemplo, sigue prohibido. En el get también sigue prohibido porque no estamos enviando ningún token. En mi login, voy a enviar también sin ningún tipo de cabecera y también vemos que está funcionando.

[10:20] Entonces recordamos los casos de uso uno a uno. Login abierto sin ningún dibujo de autenticación: funciona. Endpoint sin los datos de autenticación, sin el header de autenticación me da prohibido, funciona bien. Y cuando yo estoy enviando el token correcto me está mandando lo que yo necesito.

[10:42] Entonces esta forma ya hemos implementado ya correctamente y cubriendo la mayoría de casos de uso cómo hacer un proceso de autorización en Spring haciendo uso de los métodos de Spring. Vamos a hacer un pequeño recap de lo que hemos visto ahora, porque quizás es un poco confuso.

[11:01] El error inicial era que este filtro no estaba haciendo llamado por el otro filtro Spring porque configuramos en SecurityConfigurations que cada request tenía que ser autenticado aún no teníamos esto, entonces el filtro de Spring por defecto venía antes que el nuestro y al filtro de Spring no le habíamos dicho que tenía que llamar al nuestro.

[11:28] Recuerden este diseño siempre. Un filtro tiene que llamar al siguiente, si no nunca es llamado. Nuestro filtro no era llamado, por lo tanto lo que tuvimos que hacer es decirle: agrega un filtro antes de este filtro usando este tipo de autenticación: usernamePasswordAuthenticationFilter.

[11:47] ¿Por qué? Porque con este tipo de filtro usando, como nosotros obtenemos el token y con el token extraemos el usuario, el nombre del usuario aquí, que sería el subject, vamos a ver aquí, extract username.

[12:07] Extraemos el name, incluso hasta podemos hacerlo nombreUsuario para hacerlo un poco más autoentendible nuestro código, siempre es bueno. Entonces lo que hacemos aquí es que si el nombre de usuario no llega a null significa que para mí entonces este token es válido. Ya está aquí.

[12:28] Si esto no es nulo entonces para mí, para mi regla de negocio esto ya es válido. ¿Qué hago ahora? Fuerzo una autenticación de este usuario, username authentication token con el usuario que yo acabo de tener de la base de datos y con eso, yo ya le digo al context: “Spring por si acaso este usuario ya está autenticado”.

[12:49] Su autenticación es válida y te lo estoy indicando aquí. Por lo tanto en mi SecurityConfigurations ya esta condición en .anyRequest .authenticated ya se vuelve true, porque ya para Spring ese usuario ya fue autenticado. Entonces como siempre les digo estudien mucho, pónganle mucho empeño.

[13:10] Yo sé que toda esta parte de seguridad puede ser un poco confusa, pero no se preocupen, con un poco de práctica todo se vuelve más simple. Nos vemos.




													 14 Para saber más: control de acceso a anotaciones
PRÓXIMA ACTIVIDAD

Otra forma de restringir el acceso a ciertas funciones, según el perfil del usuario, es usar una función de Spring Security conocida como Method Security, que funciona con el uso de anotaciones en los métodos:

@GetMapping("/{id}")
@Secured("ROLE_ADMIN")
public ResponseEntity detallar(@PathVariable Long id) {
    var medico = repository.getReferenceById(id);
    return ResponseEntity.ok(new DatosDetalladoMedico(medico));
}COPIA EL CÓDIGO
En el ejemplo de código anterior, el método se anotó con @Secured("ROLE_ADMIN"), de modo que sólo los usuarios con el rol ADMIN pueden activar solicitudes para detallar a un médico. La anotación @Secured se puede agregar en métodos individuales o incluso en la clase, lo que sería el equivalente a agregarla en todos los métodos.

¡Atención! Por defecto esta característica está deshabilitada en Spring Security, y para usarla debemos agregar la siguiente anotación en la clase Securityconfigurations del proyecto:

@EnableMethodSecurity(securedEnabled = true)COPIA EL CÓDIGO
Puede obtener más detalles sobre la función de seguridad del método en la documentación de Spring Security, disponible en:

Method Security
https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html





		17 Lo que aprendimos
PRÓXIMA ACTIVIDAD

En esta clase, aprendiste a:

Los Filters funcionan en una solicitud;
Implementar un Filter creando una clase que herede de la clase OncePerRequestFilter de Spring;
Utilizar la biblioteca Auth0 java-jwt para validar los tokens recibidos en la API;
Realizar el proceso de autenticación de la solicitud, utilizando la clase SecurityContextHolder de Spring;
Liberar y restringir solicitudes, según la URL y el verbo del protocolo HTTP.










								18 Conclusión
								
								
Transcripción
[00:00] ¿Qué tal? Felicidades por haber llegado hasta esta parte. Sé que no ha sido nada fácil, hemos dedicado tres clases enteras a lo que es seguridad en sí pero es porque este skill es altamente demandado en todas las organizaciones y si bien es complicado aprender quizá la nomenclatura, la diferencia entre autenticación y autorización, con un poco de práctica y lectura, van a ver que lo van a dominar a la perfección.

[00:27] Vamos hacer un overview por lo que hemos hecho en el curso. Lo primeroi que hemos hecho fue aplicar buenas prácticas a nuestro proyecto. Hicimos, llegamos aquí y hemos refactorizado la estructura de nuestros paquetes. Ahora manejamos un paquete de infraestructura con dos subpaquetes de errores y de seguridad.

[00:50] Ya descubrimos que tú no necesitas implementar o repetir el mismo código para tratamiento de errores en múltiples aplicaciones porque con un @RestControllerAdvice tú puedes crear diferentes exception handlers, dependiendo del error que tú quieres disparar.

[01:09] También aprendimos que en el controller tú puedes retornar directamente a ResponseEntity, en lugar de retornar el objeto directo y es mejor porque solo funciona en modo wrapper con el que puedes personalizar los estados de retorno de tu método HTTP.

[01:26] Una vez que vimos cómo mejorar nuestro proyecto y ponerlo acorde a las buenas prácticas del mercado, los otros estándares, también aprendimos sobre Spring Security. ¿Qué vimos de Spring Security? Lo primero que comenzamos a ver fue a entender los conceptos de autenticación y autorización, por ejemplo.

[01:46] Ya sabes que autenticación es cuando tú con tus credenciales vía API Rest generas tu token JWT. ¿Cómo funciona esto? El API se conecta a la base de datos. Para eso tú tienes tu usuario y tu clave, tu clave guardada con el algoritmo de encriptación, en nuestro caso usamos Bcrypt, y con eso Spring hace la comparación entre los dos y nos dice si el usuario es válido o no.

[02:16] Eso lo vimos aquí y lo abstraímos completamente en el paquete de seguridad en lo que es el TokenService y el AuthenticationService. ¿Qué más vimos? Vimos que tú puedes implementar el UserDetailsService para sobrescribir el comportamiento por default que Spring nos dio.

[02:36] ¿Recuerdas cómo era la primera vez que implementamos Spring Security? Fuimos a Spring Initializr y copiamos esta dependencia que tenemos aquí: spring-boot-starter-security.

[02:47] Vimos que por defecto apenas agregas esta dependencia Spring te genera una página de autenticación, una página web autenticación para que pongas tu usuario y tu contraseña por defecto, pero recordemos que este una autenticación stateful. ¿Eso qué significa?

[03:03] Para aplicaciones web que corren dentro de un servidor ese tipo de autenticación es el default porque cada usuario tiene una sesión iniciada. Eso quiere decir tiene un lugar en la memoria de ese servidor para tener el objeto sesión almacenado.

[03:18] Como tenemos un API, el API es indiferente sobre esto por lo tanto nuestra sesión es stateless. Eso lo configuramos y sobrescribimos el comportamiento de Spring indicando que la sesión era stateless, y de la misma forma también fuimos personalizando el control de acceso a nuestro sistema. Aquí ya entramos en la parte de autorización.

[03:43] Porque una vez que el usuario está autenticado y obtiene un token, también vimos cómo podía enviarle el token en mi header, para que en este caso cada vez que yo acepto un request, validar el token, validar si no expiró que vaya el algoritmo de firma y también validar si el usuario tiene una sesión iniciada o no.

[04:03] Todo eso lo hicimos implementando nuestro filtro de aquí. Aprendimos cómo funcionan los filtros internamente. Vimos que los filtros necesitan llamar al siguiente filtro obligatoriamente, de lo contrario simplemente no va a suceder nada.

[04:21] Aprendimos a obtener el header de autorización. Reemplazamos el bearer, que es el prefijo por defecto. Y bueno, si el nombre usuario no es null, entonces obtenemos el usuario en sí y para nosotros esto ya sería una autenticación exitosa.

[04:36] ¿Cómo se lo decimos a Spring? Se lo escribimos con un usernamePasswordAuthenticationToken, iniciamos una sesión en el contextHolder, SecurityContextHolder de Spring. Le decimos: “SecurityContextHolder, dame el contexto y automáticamente iníciale sesión a este usuario, porque este usuario está autenticado”.

[04:55] De esta forma en la configuración, bueno, ya tenemos los resultados que necesitábamos. Nuevamente, como les digo, quizás a primera vista es un poco complicado de entender. Yo les recomendaría ver al menos las tres últimas clases que hemos tenido en este curso porque todo relativo a seguridad es altamente demandado en mercado.

[05:19] Hoy en día tienes que desarrollar tu software bajo la premisa de secureByDevelopment. Entonces, lo que son controles de acceso, API, autenticación, autorización. Si lo conoces y lo manejas bien, vas a tener una gran ventaja competitiva con el resto de personas.

[05:40] Esto fue todo por hoy, esto fue todo por este curso, espero lo hayan disfrutado. Cualquier duda, pueden postearlo en el foro o preguntarme directamente, no se preocupen. Siempre estoy listo para ayudarlos. Mi nombre es Diego. Fue un gusto. Nos vemos en el siguiente curso.

								