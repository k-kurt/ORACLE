




																03 Agregando dependencias
																
																
Transcripción
[00:00] Bienvenidos a la clase número 3 de su curso de Spring Boot Rest API. Hasta el momento ya hemos visto cómo enviar datos desde el cliente, en este caso puede ser una aplicación front end, mobile o incluso nuestro cliente de Insomnia, a nuestro API, a nuestro back end.

[00:18] Ya estamos recibiendo los datos aquí y lo que estamos haciendo por ahora es solamente imprimirlo. Es un buen inicio, pero aún queda mucho más por hacer. Lo que vamos a hacer en esta tercera clase son dos cosas básicamente. Lo primero si tú recibes los datos aquí tienes que hacer algo con ellos.

[00:34] Entonces lo que pueda ser sería guardado en la base de datos, enviarlo a otro API, etcétera. Nosotros vamos a centrarnos en guardarle en una base de datos. Para eso vamos a ver nuestras dependencias que tenemos hasta este momento.

[00:49] Vemos que aquí hasta ahora tenemos el spring-web que hemos estado usando, el DevTools para que no reinicie el servidor automáticamente. Lombok, que no es una librería de Spring propiamente dicho pero Spring Integra muy bien dado que es ampliamente usado en la mayoría de aplicaciones y tenemos el Spring-starter-test.

[01:17] Esto ya viene por defecto porque Spring, por buenas prácticas, tenemos que testear el código, no lo estamos haciendo ahora porque nos estamos entrando 100% e implementar el API y por fines didácticos estamos saltando esta parte. Hay un curso en Alura sobre pruebas unitarias, usando de JUnit, altamente recomendado. Entonces si quieren profundizar sus conocimientos en testing, pues es uno de los mejores cursos que pueden ver. Vamos a volver al tema.

[01:47] Ya vimos que tenemos por ahora solamente cuatro dependencias, pero si queremos trabajar con bases de datos, necesitamos algo más. Existen formas de agregar dependencias en Spring. La primera, yo podría copiar esto, pegarlo y escribir el nombre del groupId y el artifactId, el artefacto la librería que yo quiero usar, pero es muy expuesto a errores humanos, yo me puedo equivocar escribiendo, Spring puede que no encuentre la librería porque está mal escrita, la versión es equivocada, entonces nos exponemos a mucho.

[02:24] Existe una forma de agregar dependencias en Spring Boot muy interesante y es la que vamos a ver ahora. Recuerda nuestro amigo Spring Initializr. Aquí podemos generar el proyecto pero también podemos hacer un pequeño truco para agregar dependencias. Miren.

[02:42] Si yo le doy aquí en add dependencies por ejemplo yo sé que una de las dependencias que voy a utilizar es Spring data. Entonces voy a agregar Spring data JPA. Vemos que lo agrega aquí. Perfecto. Como base de datos yo voy a usar MySQL, entonces voy a decirle: “Por favor instala el MySQL driver”. Se me pasó una T. Listo, MySQL driver. Tenemos MySQL driver.

[03:09] Y vamos a instalar también Flyway. Flyway es un gestor de migraciones de base de datos. Vamos a profundizarlo en los próximos videos, no se preocupen, pero es básicamente para mantener tu base de datos como código versionado propiamente dicho. No se preocupen si no lo entienden por ahora, lo van a entender con certeza más adelante.

[03:29] Entonces agregamos Flyway Migration. Y por el momento yo creo que ya estamos okay con estas tres dependencias, no vamos a usar nada más. Nuevamente, Flyway Migration no es parte de Spring Boot, no es propia de Spring pero al igual que MySQL Driver Spring las integra muy bien porque son ampliamente usadas en el mercado y la idea de Spring es proporcionar dos herramientas lo más fácil posible.

[03:56] En este caso yo no le voy a dar clic a generate. Yo le voy a dar clic a explore. ¿Por qué? Porque si le das clic aquí lo que esto te va a dar es un overview de cómo se va a generar el proyecto. Lo que estamos viendo aquí, por ejemplo es que me está botando un archivo de build.gradle.

[04:18] Esto porque yo no seleccioné el gestor de dependencias de Maven, entonces lo que yo voy a hacer aquí es cerrar porque no es el formato en el que yo deseo descargar mis dependencias, le voy a dar close y aquí voy a seleccionar Maven. Si le doy explore, como pueden ver es prácticamente el proyecto que se me va a descargar, pero esta es una vista previa de lo que voy a tener.

[04:39] Y lo que voy a hacer aquí, simplemente es copiar estas cuatro dependencias de aquí, porque la de test ya la tenemos y no hay ninguna otra más. Yo no he agregado ninguna otro más entonces lo que hago es copiar, regreso aplicación y aquí abajo voy a pegar esas dependencias y voy a guardar.

[05:06] ¿Cómo estoy guardando? Normalmente IntelliJ puede que si está configurado dispare automáticamente un proceso de sincronización de dependencias porque como pueden ver está en rojo porque no las encuentra, no están descargadas aquí localmente, pero si no también podemos darle al botón de Maven y un refresh.

[05:26] Con el refresh vemos que aquí está diciendo que está resolviendo las dependencias del API. Esto quiere decir está descargando las dependencias. Hasta ahora tenemos solamente cuatro. Mientras descarga entonces vamos a hacer un corte en este video y vamos a retornar cuando ya estén todas las dependencias aquí.

[05:46] Bien. Todas las dependencias ya están descargadas y como podemos ver aquí, ya tenemos el árbol completo. Tenemos ya las dependencias de Flyway, tenemos el driver de MySQL, tenemos Spring data, entonces ya estamos listos para comenzar a trabajar.

[06:04] Yo ya tengo un servidor de MySQL corriendo aquí en este momento. Como este no es un curso de base de datos, entonces no se preocupen, no vamos a profundizar mucho en lo que es instalación de MySQL. Es el típico MySQL que todos ustedes conocen. En este caso yo he descargado una versión para mi computador, ustedes pueden hacer lo mismo.

[06:24] Pueden usar cualquier programa cliente. Pueden usar DBeaver, MySQL Workbench, el programa que se sientan más cómodos de utilizar. En mi caso, como yo tengo una versión Premium de IntelliJ, yo tengo un plugin aquí que me permite acceder a la base de datos.

[06:40] Entonces yo ya tengo mi base de datos configurada, tengo todo. Solo para ver si mi proyecto compila correctamente, yo le voy a dar Play para iniciar el proyecto. Y vamos a ver qué es lo que pasa, vemos que inicia, Spring está comenzando y vemos que tiene un error. ¿Cuál es el error?

[07:00] Lo que me dice es que la aplicación falló al iniciar porque no hay configurado un data source. ¿Y eso por qué sale? Porque Spring data por defecto, si es que yo ya tengo la dependencia instalada, lo primero que va hacer Spring data es buscar por una conexión con una base datos. ¿Cómo soluciono esto? Con el archivo properties.

[03:22] Voy aquí a resources y voy a application.properties y aquí yo necesito agregar tres properties para que pueda funcionar el springdata. Por ejemplo, la primera es Spring.datasource. IntelliJ me va a ayudar aquí, datasource, no quiero hikari, bueno. Voy a copiar porque creo que es más rápido así, url. ¿Cuál es la url?

[07:52] Mi datasource comienza como siempre con jdbc:mysql://localhost/vollmed-api. Vamos a usar ese nombre. Segundo, necesitamos spring.datasource.username. En mi username yo voy a usar root que es el que tengo por defecto configurado y aquí voy a copiar esto. Acá solamente voy a cambiar por password y mi contraseña que yo le configure a mi mysql local es del 1 al 8.

[08:35] Entonces con estas tres propiedades yo ya tengo listo mi configuración con la base de datos. Vamos a ver si esto es verdad. Entonces vamos a iniciar el servidor nuevamente porque falló al iniciar. Entonces lo vamos a iniciar y vamos a ver qué es lo que pasa.

[08:56] En efecto, vemos que no podemos iniciar y ahora tenemos un error diferente. Esto ya no es un error de inicio. Esto es una exception. Vamos a ver qué es lo que dice: Unknown database ‘vollmed-api’. ¿Esto por qué es? Porque en efecto esto es bueno porque ya tengo la conexión con la base de datos, pero no existe la base de datos ‘vollmed-api’, tengo que crearla.

[09:21] Para eso, entonces lo que yo voy a hacer es nuevamente ustedes pueden usar algún cliente de base de datos, el que ustedes quieran, el que más le guste. Yo voy a usar el que tengo ya integrado en esta versión de IntellyJ. Entonces lo que voy a venir es voy a entrar aquí, y voy a abrir una nueva consola para queries. La abro aquí.

[09:45] Me abre una terminal para ejecutar queries y le voy a decir create database y voy a copiar el nombre de la base datos que yo especifiqué aquí que es voll-médico.api. Entonces copiamos, pegamos y ejecutamos, vamos a ver qué es lo que nos dice. Okay, tengo un error por la sintax-api. ¿Por qué? Porque hay un error aquí.

[10:11] Entonces lo que hago es ponerle un guión bajo porque mi sintaxis está equivocada, entramos, vemos que lo creó. Vamos a ver ahora qué sucede. Y listo. Create voll-med.api, una fila afectada en 10 milisegundos. Perfecto. Entonces ahora voy a iniciar nuevamente mi servidor y vamos a ver qué es lo que sucede ahora.

[10:42] Iniciando y tenemos otra excepción, porque claro, yo actualicé mi nombre de la base de datos, tengo que actualizarlo también en mi archivo properties. Como pueden ver, tiene que estar altamente sincronizado. Le damos guardar, le damos play de nuevo, porque siempre Spring data JPA lo primero que hace es escanear y verifica que en efecto tu base de datos exista. Y ya tenemos la aplicación inicializada con la base de datos.

[11:15] Si vemos aquí vemos que en efecto ya tiene otros logs agregados en el inicio. Está usando el dialecto de MySQL con Hybernate. Esto lo vamos a explorar más adelante. No se preocupen. Pero al final vemos que aquí está iniciando la conexión con la base de datos. Entonces ya estamos listos para configurar lo que es la capa de persistencia con nuestro API. Nos vemos en el siguiente video.





														05 Entidades JPA
														
Transcripción
[00:00] Ya tenemos conectada nuestra base de datos. Tenemos todo para comenzar a trabajar. ¿Qué es lo que sigue? Tenemos que definir el modelo que vamos a utilizar para la persistencia, el modelo de tablas, la relación entre las entidades. Para esto, vamos a comenzar creando en el paquete médico nuestra clase que va a mapear la entidad médico.

[00:23] Esto no es un curso de JPA entonces vamos a hacerlo lo más directo posible. Para eso vamos a crear una nueva clase llamada médico, voy a agregar aquí y médico va a tener sus atributos. Por ejemplo, si no recuerdo los atributos serían básicamente los mismos que están aquí en el DatoRegistroMédico.

[00:47] La diferencia es DatosRegistroMedico es nuestro DTO, Data Transfer Object, que es usado para recibir lo que está viniendo del API y nuestra entidad médico que estamos creando que vamos llenar los atributos ahora, es la que vamos a usar para hacer la persistencia de datos con nuestro modelo de base de datos.

[01:09] Son atributos similares, pero utilidades muy diferentes, no lo olviden. Incluso ni siquiera necesitan ser iguales, hay casos en los que tú no necesitas exponer todos los atributos que tienes en tu entidad y el DTO te sirve para justamente solo exponer lo que tú quieres exponer.

[01:28] Sin más preámbulos, vamos a comenzar a crear. Primero un id porque es una entidad. Un id, vamos a dar un private String nombre, private String email, también necesitamos un private String documento; me equivoqué, hay un typo. Listo. También tenemos la especialidad, ella es un enum, private Especialidad especialidad. Muy bien.

[02:03] Y finalmente tenemos el private Dirección, nuevamente el tipo, Dirección. No existe aún, lo vamos a crear, tamaño dirección. Como dirección no existe lo que voy a hacer es darle clic en la flechita roja y crear class dirección, obviamente en el paquete dirección.

[02:25] Creó aquí. No lo agregó aún. Y aquí path simplemente con los atributos private String calle; private Integer número; private String complemento; private String ciudad y no recuerdo si me estoy olvidando de algo, entonces voy a entrar a DatosDirección es calle, distrito. Falta distrito. Entonces regreso aquí a mi entidad, copio esto y aquí le voy a poner distrito.

[03:00] Y ya tengo mapeados los atributos que llegan a mi DTO que sería ese ahí, pero ahora mi clase de persistencia. Y no puede ser una clase de persistencia, si no tienes las anotaciones de persistencia que sería en este caso table de persistence. Aquí le voy a poner el nombre de tabla que va a ser “médicos” y finalmente entity, que el nombre de mi entidad va a ser “Médico”. Aquí faltó el atributo, listo.

[03:42] ¿Qué más está faltando? Falta indicarle el id. Nuevamente no vamos a profundizar en esto porque no es un curso de JPA, solamente voy a completar eso. El strategy. En GenerationType va a ser identity, para el id, aquí va ser enumerated, y el EnumType va a ser un string y esto va a ser embedded. ¿Por qué?

[04:22] Porque lo que estamos haciendo en nuestro formulario tenemos todos los datos juntos, tenemos los datos del médico y la dirección, lo mismo lo vamos a plasmar en la base de datos, pero como ya vimos que Dirección lo va a usar tanto el paciente como el médico, no tiene sentido duplicar los mismos atributos en dos entidades, por eso lo estamos dividiendo.

[04:46] Y lo que vamos a hacer es ahora anotar dirección con embeddable. Muy bien. No es una tabla. Es solamente una clase que es embeddable en la otra para que la incluya nada más. Yy con esto ya tendríamos listo lo que es nuestro modelo, nuestra definición de JPA para mapear nuestras entidades.

[05:13] Pero como toda clase, necesitamos crear constructor, getter y yo no quiero tener que escribir a mano ese código repetitivo, no tiene caso, no tiene sentido para mí y es aquí donde entra Lombok en acción, ¿por qué? [05:32] Porque como les dije antes, Lombok lo que hace es generar automáticamente el código que no tiene sentido escribirlo por ti mismo, por ejemplo, si tú quieres generar getters, le vas a poner la opción getter de Lombok y automáticamente una vez que compile, Lombok va a generar automáticamente los getters para todos estos atributos.

[05:55] Es más, necesito un constructor sin atributos, entonces le va a poner NoArgsConstructor para un constructor default y un constructor con todos los atributos pongo AllArgsConstructor. Y finalmente aquí lo que necesito, déjame buscar un poco aquí, es implementar mi EqualsAndHashCode.

[06:20] EqualsAndHashCode lo que va a hacer es usar el parámetro id para las comparaciones entre médicos, por ejemplo, aquí add of, listo. Entonces dependiendo del parámetro id, si los id son iguales va a inferir que son iguales. Como si yo sobrescribiera el método hashcode y el método equals en mi clase, pero Lombok lo va hacer por mí.

[06:48] De igual forma le vamos a hacer para dirección. EqualsAndHashCode por qué dirección no tiene id. Lo copio y no hay ningún problema Así es cómo ya tengo finalmente mis entidades mapeadas listas para implementar mi persistencia en la base de datos. ¿Pero qué es lo que está faltando aquí?

[07:13] Vamos al MedicoController. Hasta ahora, una vez que recibimos los datos del registro médico, solo los estamos imprimiendo en la terminal. ¿Qué es lo que debemos hacer ahora? Debemos crear una capa extra en la que vamos a tomar los datos que llegan, transformarlos, vamos a transformarlos a nuestras entidades y estas entidades van a persistir en la base datos.

[07:39] Antiguamente se usaba lo que es el patrón DAO, Data Access Object en el cual tú tenías que crear tu entity manager, gestionar la sesión. Y si usabas Hybernate crear tu prepared statement, todo lo que eso conlleva, un código extenso que la verdad que no lo recuerdo de memoria, es muy extenso para recordarlo, necesitaría ver documentación.

[08:04] Pero ya ha pasado muchos años de esos tiempos, ahora hay formas mucho mejores de hacerlo, obviamente Spring nos hace la vida mucho más fácil. Es el tema del siguiente video.





															06 Interfaces repository														


Transcripción
[00:00] Ya explicamos que lo que necesitamos ahora es crear la integración, la capa que nos va a permitir pasar de esto a registros en la base de datos usando esto. Entonces les expliqué que antiguamente teníamos el patrón DAO en el cual tenías que crear tu entity manager, definir tu conexión con base de datos, crear la conexión, cerrar la conexión y era un trabajo muy engorroso.

[00:28] Ahora lo que vamos a hacer es crear repositorios. ¿Cómo es eso? Entramos aquí al médico y le voy a dar clic derecho y voy a crear una nueva interfaz en este caso: MedicoRepository, vamos a crear repositories y el del tipo interface. Entonces con esta interfaz nosotros vamos a ser capaces de hacer todo el proceso de gestión con la base de datos a nivel del CRUD: crear, guardar objetos, listar, actualizar, etcétera, pero automáticamente. ¿Por qué?

[01:09] Porque vamos a extender de otra interfaz llamada JpaRepository y está interfaz es propia de Spring data también, pero JpaRepository necesita dos parámetros. El primer parámetro es el tipo de objeto que yo voy a guardar aquí, por ejemplo, en este caso es médico, que es la entidad que yo voy a salvar, es el tipo de entidad con el que yo voy a trabajar en este repositorio.

[01:36] Segundo, necesito el tipo de objeto del id. Entonces en este caso sería un Long. Entonces, si se dan cuenta si reconocen lo que es esto, estos son generics. Eso quiere decir que si aquí entró a JpaRepository, primero que todo vemos que usa los generics aquí, T, tipo de objeto, id, el id que voy a usar y tiene métodos aquí como saveAndFlush, usando los generics, delete, deleteAll, getOne, getById en caso necesite uno, está deprecado.

[02:14] Hay otros métodos más eficientes, pero vemos que findAll, usando los mismos generics. Vemos que está interfaz nos brinda métodos que van a ser muy útiles en el futuro y yo no voy a necesitar escribir ni una sola línea de código. Así de simple, ni una sola línea de código. Yo tengo mi repositorio. Eso es todo lo que tengo que hacer. No tengo que hacer nada más.

[02:43] Ahora lo que voy a hacer es entrar a MedicoController y llamar a ese repositorio, ¿cómo lo hago? Simple. Voy a crear a mi MedicoRepository, voy a llamarlo aquí y Spring tiene una anotación especial para decir Spring, necesito que de tu contexto busques este objeto de aquí, este MedicoRepository y me lo envíes, me lo inyectes, para no tener que crear uno nuevo.

[03:15] Si no, yo tendría que darle digamos un igual new y la implementación del MedicoRepository, la cual no la tengo. Spring la tiene internamente. Para eso yo voy usar una anotación autowired. Vale resaltar aquí que no es recomendable por fines de testing, no es recomendable usar autowired a nivel de la declaración del parámetro del atributo.

[03:41] No es recomendable porque si ustedes quieren usar pruebas unitarias con esto, van a tener problemas, va a ser muy difícil que puedan hacer un mock de MedicoRepository. En fin, este no es un curso de testing pero es un consejo que les doy. Ahora por fines didácticos no lo vamos a hacer. Otra forma de hacer la inyección de dependencias con autowired sería con setter, pero lo vamos a dejar así por ahora.

[04:08] Pero recuerden: esta forma es una forma abreviada para fines didácticos, pero no se las recomiendo usarla en la práctica. Volvamos al tema. ¿Y aquí qué es lo que tengo que hacer? Simple. Tengo mi MedicoRepository y aquí cuando tengo acá le voy a dar un save. ¿Save de qué? Save de datosRegistroMedico y vemos que me está dando un error de compilación. ¿Por qué?

[04:40] Porque aquí si se dan cuenta save usa el generic que yo le estoy enviando como parámetro. Si vengo a mi MedicoRepository, como parámetro yo le estoy mandando un objeto médico y no un objeto DatosRegistroMedico, entonces ahí yo tengo ya un digamos un conflicto. Yo tengo dos opciones aquí.

[05:04] La primera crear un método que me traduzca y me haga el mapeo, digamos así, de DatosRegistroMedico a médico o la otra solución, simplemente voy a cargarle un constructor, voy a entrar aquí, voy a crearle un constructor a médico, new Medico que acepte como parámetro los datos de registro del médico. Aquí podría ser tranquilamente, datosRegistroMedico.getNombre y etcétera.

[05:39] Pero no es lo que yo quiero hacer por ahora porque si no mi método quedaría muy extenso. Entonces lo que voy a hacer directamente es decirle: “médico constrúyete un constructor que acepte como parámetro un dato registro médico”. Y es lo que voy a hacer en este momento.

[05:59] Vengo a Medico. Y le voy a decir create constructor y aquí vemos, pues que ya tiene un public Medico(DatosRegistroMédico). Aquí lo que voy a hacer es hacer el mapeo de this.nombre = datosRegistroMedico.nombre(), this.email = datosRegistroMedico.email(), this.documento = datosRegistroMedico.documento(), this.especialidad, la misma historia .especialidad, porque ese mismo tipo de objeto entonces no hay ningún problema.

[06:54] Y finalmente this.dirección = datosRegistroMedico.direccion. Y vemos que aquí me está dando un error de compilación, porque él necesita un objeto de tipo dirección pero yo le estoy dando datos dirección. Entonces aquí yo tengo otro pequeño issue con esto.

[07:17] Para eso yo lo que voy a hacer aquí es darle un new Dirección y esa dirección va a recibir como parámetro los datos de registro de Dirección. No lo copié bien, le voy a dar cortar, voy a darle aquí "Ctrl + X". Listo. Y la misma historia. ¿Qué voy a hacer aquí? Simple, voy a darle un constructor a dirección y repetimos exactamente lo mismo aquí.

[07:48] this.calle = direccion.calle(), this.numero = dirección.número(), this.distrito = dirección.distrito(), this.complemento=dirección.complemento(). Vemos que tenemos un error de compilación de número y debe ser por el tipo de dato. Y finalmente tenemos ciudad. Eso lo vamos a copiar así, para no tener que estar escribiendo todo a cada momento.

[08:40] Vemos que en número me está dando un error de compilación porque del DTO que yo estoy enviando, acá String, para no complicarme la vida voy a usar solo strings aquí. No va a tener ningún impacto. Ya tengo mi médico bien mapeado. Tengo mi dirección mapeada y tengo mi repositorio creado.

[09:05] Parece que todo está bien implementado. Ahora voy a venir a mi controller. Mi controller también ya no tiene ningún tipo de error, ya compila todo perfectamente, tengo mi MédicoRepository, tengo mi Medico entidad que está recibiendo el DTO. Vamos a probar este código, vamos a ejecutarlo. Entonces le doy a play. Vamos a play, vemos que está iniciando.

[09:40] Y la aplicación inició en 4 segundos. Vamos a dar limpiar esto, no necesitamos, venimos a Insomnia y disparamos nuestro request para ver si lo va a guardar en la base datos. Y sale un 500 internal server error. Alguna cosa sucedió en el back end y vamos a ver aquí qué es lo que nos está diciendo.

[10:01] Dice la tabla ‘vollmed_api.medicos’, o sea la tabla que hemos definido aquí en nuestro entity, no existe. ¿Por qué? Porque si vemos aquí, en nuestro UI de la base de datos, en nuestro cliente de base de datos, tenemos la base de datos vollmed_api. Perfecto, existe, pero no nos creó ninguna tabla. No hay ninguna tabla. Entonces aquí tenemos nuevamente igual dos opciones.

[10:35] Podemos tranquilamente usar el cliente visual, darle a new table y crear la tabla, ejecutar el código o podemos usar una herramienta que pueda hacer eso por nosotros y tenerlo versionado. Alerta de spoiler. Es Flyway. Y eso lo vamos a ver en el siguiente video.





																				
																				
																				08 Migraciones flyway #1
																				
																				
Transcripción
[00:00] Bien, ya vimos que el error que tenemos ahora es porque no tenemos la tabla médicos creada, no existe y para eso vamos a hacer por fin uso de la herramienta Flyway. Si ustedes recuerdan en el primer video de esta clase, seleccionamos Flyway como parte de las dependencias para descargar ahora.

[00:24] Si vemos el pom vamos a ver que de Flyway tenemos dos dependencias. La primera es flyway-core y la segunda es flyway-mysql. Flyway-core s la que nos va ayudar, digamos a hacer el trabajo en realidad de ejecutar las migraciones que es cómo se llama esto, y flyway-mysql es para el dialecto de base datos que vamos a utilizar, en este caso, MyQSL, valga la redundancia.

[00:45] Este tipo de herramientas son llamadas migrations. Son herramientas de migración de base de datos. Tranquilamente puede ser Flyway, tienes Liquibase, pero Flyway es ampliamente adoptado en el mercado y en principio es el mismo. No se preocupe si entienden flyaway, van a ser capaz de trabajar con cualquier tipo de migration con que se topen en su vida profesional.

[01:07] El principio es el mismo: es gestionar tu base de datos a través de código. ¿Cómo funciona esto? Yo como les dije podría tranquilamente darle clic derecho aquí, darle a new y crear mi tabla, pero yo lo quiero hacer usando Flyway. Para eso voy a venir aquí a mi carpeta de recursos, resources, darle clic derecho new, directory y voy a llamar migrations.

[01:36] Entonces ya tengo mi carpeta migrations y automáticamente Flyway la va detectar y va a decir: “Aquí está la migration de la base de datos”, pero hubo aquí algo que olvidé y es crear la carpeta primero, la carpeta padre db, y migrations va dentro de db. Esto por estructura de Flyway. Aquí en IntellyJ me la va a mostrar como db.migrations, pero en realidad es el directorio migrations dentro de db, por database.

[02:14] Sin más que decir nuevamente clic derecho, new. Los migration se gestionan con archivos .sql, lo que hace por principio ¿qué es? Ve el archivo sql y lo va a ejecutar sobre la base de datos con la que ya tiene conexión. Entonces, si yo quiero un archivo sql le voy a dar en file y aquí entra algo muy importante, pongan atención en esto.

[02:42] Flyway utiliza una nomenclatura, un tipo de padrón para nombrar los archivos con el cual él identifica qué archivo ya fue migrado y cuál no. Por ejemplo esta es la primera migration. Entonces es v1__ dos guiones bajos y de preferencia el nombre tiene que ser autoexplicativo. Por ejemplo, si yo voy a crear aquí la base de datos, voy a ponerle create-table, porque voy a quedar la tabla médicos, perdón, no voy a crear la base datos.

[03:20] Médicos.sql. Entonces, nuevamente el v1 y los dos guiones bajos es el patrón de Flyway para identificar qué es una migration y él va a decidir si se ejecuta o no, eso lo vamos a ver en práctica en unos minutos, pero solo para que la atiendan por ahora. Segundo, la segunda parte del nombre es algo autoexplicativo sobre lo que esta migration está haciendo. En este caso estamos creando una tabla llamada médicos.

[04:00] Entonces create-table-medicos. Y la tercera parte es la extensión del archivo .sql. Lo creamos y tenemos aquí create-table-médicos, tenemos aquí que escribir el código para crear la tabla. El código ya lo tengo aquí, no es un curso de MySQL entonces no vamos a profundizar mucho en la sintaxis, pero es básicamente esto: create-table-medicos, todo lo que ustedes ya conocen, aquí no hay mayor ciencia, no hay mucho que ver en realidad.

[04:35] Y diciendo primary key y listo, ya tenemos nuestra migration creada aquí, create-table-medicos. Ya tenemos el servidor porque si en algún caso, por ejemplo llega a ejecutarse, si yo llego guardar este migration y por ejemplo, si mi scribd está incompleto, puedo tener errores en mi base de datos luego.

[04:59] Entonces de preferencia si van a trabajar con migrations y con DevTools activado detengan el servidor porque si por ejemplo hay algún error de compilación aquí, si yo aún no termino de escribir, por ejemplo, mi tabla, pero quiero guardar, entonces mi tabla se va a crear con estos atributos.

[05:20] Quedamos aquí y vamos a iniciar el servidor. Vemos aquí que ya tenemos en el Flyway Community Edition, y me dice aquí por ejemplo: No migrations found. Are your locations set up correctly? Esto me dice claramente, si yo creé una migración, quizás el directorio no está nombrado correctamente. Y creo que es verdad porque yo escribí migrations en plural y debería ser en singular.

[06:08] Para eso voy a hacer un refactor. Y ya está db.migration. Voy a entrar a mi servidor nuevamente. Y vamos a ejecutar nuevamente ahora. Vamos a ver qué sucede. El servidor inicializó. Vamos a incrementar esto un poco y vamos a ver ahora sí que nuestro directorio está correctamente nombrado. Vemos que inicia aquí Flyway Community, etcétera, y 1 SQL migrations were detected.

[06:44] Pero no corrió porque no está siguiendo la convención del filename. ¿Eso qué quiere decir? Hay un error aquí en el cual no está consiguiendo identificar la versión correcta de Flyway. Vamos a explorar este error ahora.







																				09 Migraciones flyway #2
																				
Transcripción
[00:00] Dado que el error está en la sintaxis, es por el inicio por la v, como decimos en mi país o v también, debería ser también mayúsculas. Entonces aquí lo que vamos a hacer es V1, pasamos a refactor, nuevamente tenemos el servidor para evitar cualquier tipo de problemas, vamos a borrar estos logs e iniciar nuevamente para ver cómo es este proceso. Iniciamos.

[00:30] El servidor inició correctamente y vamos a ver los logs. Flyway inicia y vemos aquí que inicializó con base de datos, inicia correctamente y successfully validated 1 migration y la ejecutó en 18 segundos, perdón 18 milisegundos prácticamente. Vemos que creó la tabla médicos y satisfactoriamente aplicó una migración ahora, en versión 1.

[01:10] Tenemos aquí, vemos que tiene una tabla que es la tabla del esquema de Flyway. Flyway yo me refería a esto con la nomenclatura. Internamente Flyway maneja las versiones en su propia tabla de modo que él identifica que V1 ya fue ejecutado por lo tanto voy a refrescar aquí para ver las tablas y vemos que ya tengo mi tabla médicos.

[01:37] Ya está aquí con dos atributos que yo le he especificado. Todos mis atributos con el tipo de datos que yo quiero. Ahora por ejemplo, ustedes me preguntarán si esto ejecutó cuando el servidor inició, ¿significa que si ejecuto nuevamente va a crear la base de datos nuevamente? No. Y eso lo vamos a probar ahora. Voy a detener el servidor. Si ustedes pueden ver aquí dice claramente que se aplicó a la migration.

[02:07] Entonces voy a borrar esto y voy a ejecutar el servidor nuevamente. El servidor inicia pero esta vez si vemos aquí, válido una migración, pero el esquema vollmed_api está al día, no migration necessary. ¿Por qué? Porque en esta tabla que están viendo aquí de flyway_schema_history él aquí ya sabe que esta migration que inicia con V1 ya fue aplicado, por lo tanto no es necesario que la vuelva a aplicar.

[02:47] Y por esto que se llama un sistema de versión de base de datos, porque si necesitas aplicar más migrations, por ejemplo, creas un V2, Flyway va a detectar que no la tiene y simplemente va a ejecutarla. Vamos a ver si está funcionando correctamente nuestra aplicación. Vamos a ejecutar nuestro cliente, vamos a enviar nuevamente los datos, tengo solamente 500 internal server error.

[03:16] ¿Y ahora, qué es lo que pasó? Venimos por aquí. ¿Y qué nos va a decir? Columna ‘calle’ no puede ser nula. Eso es un dato muy interesante, porque ya nos estamos dando cuenta que tenemos que comenzar a validar algunos campos que están llegando aquí. ¿Por qué? Porque simplemente aquí tenemos el constrain de que no puede ser null.

[03:44] Si se dan cuenta aquí en la base de datos le hemos dicho: “no queremos que ningún atributo sea nulo”. Aquí está, a excepción de número y complemento, porque en direcciones esto es opcional. ¿Qué es lo que sigue ahora? Correcto. Ahora vamos a comenzar a ver lo que son validaciones. Eso es un tema de siguiente video. Nos vemos.





																				10 Validación
																				
																				
																																								Transcripción
[00:00] Ya vimos que el tema de validaciones es importante porque en este caso nuestra operación falló porque la columna ‘calle’ no puede estar nula. Ahora, esta validación ocurrió a nivel de la base de datos porque está especificado que es not null.

[00:17] Pero la pregunta que yo les hago a ustedes: ¿Creen que las validaciones se deberían manejar dependiendo a nivel de base de datos o ustedes creen que eso debería ser hecho unos niveles más arriba, incluso antes de que llegue a hacer contacto o interacción con la base de datos?

[00:38] Por ejemplo, aquí calle llegó nulo. La razón del problema es porque en el payload no está especificado. Entonces, en efecto, ya vimos que cuando no especificas un atributo llega nulo. Si yo aquí creo el atributo, por ejemplo que digo, “calle”: “Calle 1”, y envío ahora, vemos que me da un okay, entonces funcionó.

[01:05] No hay ningún error. Si le doy doble clic a mi tabla médicos, vemos aquí claramente que el id me lo autogeneró número 3. Es 3 porque yo ya hice dos pruebas antes y el id es autogenerado, entonces por esto está número 3. Y vemos claramente que los nombres que yo he enviado son los correctos, entonces ya está funcionando.

[01:29] Pero a nivel de validación si yo nuevamente le retiro algún parámetro, vamos a ver que entonces voy a tener problemas a nivel de validación. Para eso necesito usar un módulo que se llama validation. Ustedes ya saben cómo agregar módulos, es simple, voy a detener mi servidor ¿y qué es lo primero que hago si yo necesito un módulo? Simple.

[02:10] ¿Qué es lo primero que yo hago si necesito un módulo extra? Voy a Spring Initializr, eso como yo lo dejé abierto, le voy a agregar una dependencia llamada validation, que es el bean validation con Hibernate validator. Entonces, nuevamente voy a explorar aquí y voy a buscar por la dependencia que yo acabo de agregar, que en este caso es validation.

[02:36] Esta es. Voy a copiar. Entro a mi pom.xml, voy al final y la voy a pegar aquí. Voy a guardar. Entro al módulo de Maven, servidor definido y voy a darle un refresh a mis dependencias y vemos cómo ahí comienza a resolver las dependencias del API. Como es solamente una dependencia ya terminó, muy simple, muy fácil y vamos a buscar en dónde está. Aquí al final: spring-boot-starter-validation.

[03:17] Entonces, ya estamos listos para validar a nivel del API, no de la base de datos. Ahora, si deberíamos validar donde están llegando los datos ¿dónde deberíamos hacer las validaciones? En el DTO. Entonces, llegamos aquí, DatosRegistroMedico, cerramos lo demás para no tener distracciones, close other tabs, limpiamos la terminal, un poco de orden siempre.

[03:50] Y vamos a ver que tenemos los parámetros aquí, por ejemplo, nombre, ya sabemos que no puede llegar vacío, entonces bean validation a través de anotaciones a través de anotaciones nos da facilidades, como por ejemplo si le quiero poner aquí not null va a validar que nombre nunca llegue null. Lo mismo, por ejemplo con email.

[04:15] Lo que yo voy a hacer ahora por fines de orden, voy a darles saltos de línea a cada atributo, solo para que se vea visualmente mejor y voy a iniciar las validaciones, por ejemplo, nombre puede llegar nulo o puede llegar en blanco, pero en ninguno de los casos yo debería aceptarlo.

[04:36] Entonces, recuerden, nulo no es lo mismo que vacío, entonces yo aquí le puedo poner NotBlank también. NotBlank, pero internamente NotBlank también hace lo mismo que NotNull. Entonces, voy a borrarle NotNull y esto ya va a validar que nombre no llegue ni nulo ni blanco. Es lo primero.

[05:05] Segundo el email, o sea, vamos a ponerle igual NotBlank, pero como es un email, yo quiero que valide que el formato de email es el correo. ¿Qué le pongo? Email. Perfecto. En documento vamos a hacer algo parecido, igual NotBlank porque no aceptamos ningún parámetro en blanco, pero también vamos a darle un patrón que sería una anotación pattern, porque los documentos por regla de negocio deberían tener solamente números.

[05:40] Entonces en pattern lo que hacemos aquí es definir una expresión regular en la cual vamos a ponerle backslash, dos puntos y que sea de 4 a 6 dígitos. Esa sería nuestra expresión regular que deseamos para nuestro patrón. Vemos que necesitamos el atributo regEx porque es una expresión regular como dijimos y ya está.

[06:03] Entonces eso es un número de 4 a 6 digitos, perfecto. La especialidad tampoco puede llegar null, entonces nuevamente NotBlank. Y la dirección de la misma forma, NotNull, porque es objeto. No NotBlank porque dado que es un objeto, no va a llegar en blanco, va a llegar nulo siempre, recuerden.

[06:25] Y en datos de dirección hacemos exactamente lo mismo, vamos aquí y nuevamente en calle NotBlank y esto aplicaría básicamente para todos los demás. Entonces, por fines visuales nuevamente, le voy a dar saltos de línea a cada uno. Y copiar NotBlank arriba de cada uno también. De esta forma, me aseguro que la validación ocurra a este nivel. Y estamos completos.

[06:56] Entonces voy a iniciar mi servidor nuevamente. Esperamos un poco a que mi máquina responda, ya tiene algunos años. Vemos que la aplicación inicializó y vamos a hacer la prueba nuevamente. Por ejemplo, le voy a cambiar aquí el documento, le voy a poner otro número de documento, 6 dígitos. Voy a enviarle. Vemos que dio un error aquí. ¿Y cuál es el error esta vez?

[07:29] Vamos a ver qué es lo que nos dice y dice: entrada duplicada por el email, porque esta validación sí es buena que ocurra base de datos porque el constrain, el que te va a comparar si eso ya existe o no es la llave de aquí el unique, que está aquí en la base de datos. Entonces, esa comparación sí debe ir a nivel de base de datos, porque si no, tú tendrías que hacer dos queries en una y no es el objetivo que queremos aquí.

[07:58] Entonces yo le voy a poner aquí otro identificador, un carácter2 solamente para validar que es diferente, le voy a dar enviar. Da 200. Reviso mi base de datos lista médicos y ya está con el nuevo email. ¿Ahora qué pasará? Voy a limpiar eso nuevamente. ¿Qué pasará si yo no le mando mi nombre?

[08:24] Le doy a enviar y aquí me da un error. También 500. ¿Qué me dice? La misma validación, la columna ‘nombre’ no puede ser nula. Vemos que es el mismo error que teníamos con la base de datos y ustedes dirán: “No, Diego, pero tú dijiste que esa validación no debía ser a nivel de base de datos. Tú dijiste que eso debía ser a nivel del objeto.”

[08:49] Está bien, a nivel de objeto, pero si se dan cuenta hemos implementado las validaciones aquí, ¿pero qué falta? En el controller, en ningún momento le hemos dicho: “valídame este objeto, este DTO”. ¿Por qué? Porque aquí entra la notación valid. Entonces, con valid lo que él nos dice es él va a validar que en DatosRegistroMédico todo sea válido.

[09:22] Y en DatosRegistroMédico, lo que vamos a hacer es darle un NotNull y otro valid a la dirección para que internamente también nos valide que la dirección que estamos recibiendo contenga todo lo que nosotros deseamos que contenga. Entonces voy a guardar aquí. El servidor va a reiniciar, voy a limpiar mi terminal.

[09:48] Vemos que el servidor ya inició nuevamente, y nuevamente voy a enviar aquí. Veo que tengo otro error. Pero aquí nos está diciendo: No validator could be found for NotBlank, para especialidad. ¿Por qué? Porque especialidad es un enum. Entonces nuevamente aquí también debe ser NotNull. Venimos aquí. NotNull, igual para especialidad. Guardamos, pero si se dieron cuenta, ahora ya ocurrió a nivel del bean validation y no a nivel de base de datos.

[10:24] Mis validaciones están funcionando, eso es bueno, eso es justamente lo que nosotros queremos. Limpiamos, enviamos y nos da un bad request ahora. ¿Cuál es el significado de un bad request? Que tus payloads, tus parámetros que has enviado no coinciden con el body que está esperando el API. Este tipo de respuesta es muy útil porque el cliente ya le va a entender que el error está a nivel del payload y no a nivel del servidor en sí.

[10:56] Y esto ya te ayuda mucho en la detección de errores porque no te estás preguntando: ¿será error en el servidor? ¿Será error de mi lado? No, el bad request ya te dice que el cliente está equivocado. Tú me estás enviando algo que yo no te voy a aceptar, es un bad request. ¿Y qué es lo que dice aquí? Vamos a ver.

[11:15] En springframework, en el método, etcétera, vamos a ver aquí. En el campo ‘nombre’: rejected value null. ¿Por qué? Porque nombre llegó en blanco. Perdón, nombre llegó null porque no está especificado. Vamos a probar ahora con nombre en blanco. Vamos aquí a nombre y que llegue en blanco. Vamos a enviar.

[11:39] Igual bad request, porque vemos aquí nuevamente dato registro en el campo nombre fue rechazado porque está vacío. De esta forma no hubo ningún tipo de interacción con la base de datos, porque la validación ocurrió a nivel del DTO. Entonces es muy importante, es muy útil porque un error 500 puede ser cualquier cosa, pero un error 400 ya te dice: “Este error no es a nivel de mi API, es a nivel del cliente”.

[12:11] Esa es la parte más importante de ahora. Es prácticamente todo lo que tenemos que ver por esta clase, pero queda un último punto muy interesante porque yo me olvidé de colocar el teléfono en mi DTO. Y también en mi entidad médico. ¿Ahora qué hago? Lo vamos a ver en el siguiente video.








																				13 Nueva migración
																				
																				
Transcripción
[00:00] Este último video es un caso que van a ver muy seguido en el mundo laboral y es un pedido, un caso de uso normal, es lo más común, entonces es bueno que lo vemos aquí. En mi caso, yo me olvidé de agregar el teléfono. Aquí vemos que en el formulario que necesitamos llenar el teléfono no está presente aquí, pero me piden dar un teléfono del médico para contactarlo obviamente, fuera del email.

[00:33] Entonces, puede ser que de repente en tu trabajo algún día te digan por regla de negocio necesitamos agregar un nuevo campo, porque al final es lo que vamos a hacer, agregar un nuevo campo aquí. ¿Qué hacemos ahora? Bueno. Podemos hacerlo de dos formas. Como siempre les digo, podemos agregarle aquí clic derecho en tu cliente y agregar una columna, el modo más fácil, o través de migraciones.

[00:54] Si vamos a trabajar migraciones, como ya vimos, hay que detener el servidor, lo detenemos aquí, limpiamos esto. Y venimos aquí a nuestra carpeta de migrations. ¿Y qué hacemos? ¿Cuál es el primer paso para crear una migration? Correcto. Vamos a crear el archivo SQL. Entonces vamos a file y si ya tengo V1, ¿cuál será el nombre para este? V2. Perfecto V2__ y el nombre del archivo.

[01:26] En este caso, si voy a agregar una nueva columna a mi tabla es un alter table, entonces alter-table-medicos-add-telefono. Y la tercera parte del nombre es el punto SQL, es la extensión del archivo. Entonces tenemos aquí el V2, el alter-table, que es el nombre autoexplicativo de lo que esta migración está haciendo y el punto SQL.

[02:00] Perfecto. Le damos enter. Lo agregamos a Git y ya está. Y ponemos el código para agregar el teléfono. Entonces vemos que no puede llegar nulo, etcétera. Y listo. A nivel de base de datos, a nivel de migración, eso es todo lo que hay que hacer, pero recuerden, no puede ser nulo.

[02:25] Entonces necesitamos actualizar también en nuestra entidad médico, entonces lo que yo voy a hacer aquí es decirle private String, porque aquí en el tipo de dato, es un varchar, aquí va a ser un String, que va a ser teléfono. Listo. Entonces aquí yo le voy a agregar this.telefono = datosRegistroMedico.telefono() y me va a dar un error porque obviamente no existe. ¿Qué tengo que hacer aquí?

[03:08] Crearlo ahí también. Entonces voy a entrar aquí a datosRegistroMedico, voy a venir aquí abajo de email y voy a crear String teléfono y también NotBlank. Podría agregarle una validación para el formato también para un patrón de teléfono, pero ya lo hemos visto con documento. No vamos a repetir ahora. Entonces ya tenemos teléfono, no puede llegar blanco. ¿Qué significa? Ni nulo ni vacío.

[03:39] Ya está aquí. Entonces voy a recibir, ya lo estoy mapeando en médico, ya está llegando aquí. Por lo tanto ya va a estar aquí en mi base de datos también entonces, ahora vamos a ejecutar y vamos a ver los logs, vamos a ver qué nos dice ahora Spring Boot. Esperamos un poco, vemos que inicializó, vamos a revisar qué es lo que pasó.

[04:02] Aquí en Migrating to version 2. ¿Por qué? Porque ya detectó la nueva migración. Esto es a los que yo me refería. En la base de datos de Flyway que está aquí, él ya agregó ahora la versión 2, ya la tiene versionada. Satisfactoriamente se aplicó una migración, está la versión 2, por lo tanto, ya tenemos el nuevo campo listo y disponible para ser usado.

[04:30] Vamos a probar si esto de verdad está funcionando, entonces voy a cambiar totalmente los datos aquí. Voy a poner un nombre, por ejemplo Erick Cárdenas. En nombre va a ir Erick Cárdenas. En el documento ya vimos que es unique también, dos datos iguales, aparece Calle 2, distritos, etcétera, solo dos diferentes para que no se vea igual también en la base de datos. Es información de prueba, entonces puede ser cualquier cosa.

[05:04] Tenemos aquí nuestro payload ya está con el nombre. No está con el teléfono. Entonces, si yo le voy aquí a enviar recibo un bad request porque en el campo teléfono no hay ninguna información aquí. Entonces rejected value porque está nulo. ¿Qué voy a hacer? Voy a agregar el teléfono. Creo aquí teléfono. Y voy a ponerle un teléfono cualquiera. Listo, porque es un varchar, va a soportar todo.

[05:41] Ahora se lo voy a enviar y me da un 200. Entonces, si reviso aquí en mi tabla médicos, vamos a ver que Erick Cárdenas fue guardado y ya tiene un número de teléfono agregado. ¿Por qué? Porque la migración corrió satisfactoriamente y agregó el nuevo campo, tanto a nivel de la base de datos como a nivel de la entidad y a nivel de nuestro DTO.

[06:11] Entonces, como les dije, este es un caso de uso muy común en el trabajo. Practiquen bastante esto porque es más común de lo que se imaginan. Yo lo he aplicado creo que infinitas veces en mi día a día laboral. Es normal que se agreguen campos, incluso que se eliminen campos, que se dividan tablas, y ese es el poder de los migrations.

[06:36] Tú puedes gestionar completamente toda la evolución de tu base de datos a través de código SQL. Eso significa que si tú haces una migración a otra base de datos, no te preocupes porque te la llevas contigo, son migrations. Como siempre les digo, dudas en el foro, nos vemos en la siguiente clase porque ya sabemos cómo guardar elementos, pero ahora hay que listarlos, tenemos que listar los médicos. Estudian, practiquen, nos vemos.





																					Lombok, como se dijo anteriormente, es una biblioteca de Java especialmente enfocada en la reducción de código y en la productividad en el desarrollo de proyectos en ese lenguaje.

Él utiliza la idea de anotaciones (familiar a Spring ¿no?) para generar códigos en el tiempo de compilación. Pero recuerde que no vemos el código generado, y tampoco es posible cambiar lo que se ha generado.

Puede ser una buena herramienta aliada a la hora de escribir clases complejas, siempre que el desarrollador tenga conocimiento sobre ella. Para más información vea la documentación de Lombok: https://projectlombok.org/







																					Traducido del inglés, la palabra Autowired sería ''un cable automático''. En el contexto del framework Spring, que utiliza como una de sus bases el patrón de diseño “Inyección de Dependencias”, la idea sirve para definir una inyección automática en un determinado componente del proyecto Spring, ese componente puede ser atributos, métodos e incluso constructores.

Esta anotación se permite con la ayuda de la anotación @SpringBootApplication, en el archivo de configuración de Spring, disponible cada vez que se crea un proyecto Spring.

Al marcar un componente con la anotación @Autowired le estamos diciendo a Spring que el componente es un punto donde se debe inyectar una dependencia, en otras palabras, el componente se inyecta en la clase que lo posee, estableciendo una colaboración entre componentes.

Para más información sobre la anotación, echa un vistazo a la documentación oficial: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html







																					En esta clase, aprendiste a:
Agregar nuevas dependencias en el proyecto;
Asignar una entidad JPA y crear una interfaz de Repositorio para ella;
Utilizar Flyway como herramienta de migración de proyectos;
Realice validaciones con Bean Validation usando algunas de sus anotaciones, como @NotBlank.

																