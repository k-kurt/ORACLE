


														02 Clases de validación
														
Transcripción
[00:00] En la parte anterior nosotros realizamos todo lo que sería el cuerpo de las clases que nos van a permitir agendar una consulta en la base de datos para un paciente un determinado médico, entonces nosotros creamos la clase de consultaController, es la clase encargada de comunicarse con las API externas, recibir la información y guardarla en la base de datos.

[00:24] Sin embargo, nosotros dentro de la tarjeta de Trello vimos que tenemos algunas reglas que deben cumplirse, entonces nosotros tenemos que validar que ese ID existiera en la base de datos y tenemos que validar otras reglas de negocio que fueran para lo que nosotros construimos una clase de servicio para evitar colocar todas esas responsabilidades dentro de la clase controlador, ya que es la responsabilidad de la clase controlador únicamente comunicarse con APIs externas.

[00:56] De lo contrario violaría los principios de Liskov. Entonces, cada clase tiene que tener una única responsabilidad. En la clase de servicio la responsabilidad de ella va a ser procesar esa información para poder posteriormente enviarla al repositorio y guardar esa información en la base de datos.

[01:16] Nosotros podríamos colocar acá nuestras validaciones. De la misma forma que hicimos a la hora de seleccionar médico, que era una de las reglas de negocio, indicaba que en caso de que el médico fuese nulo, el id del médico fuese nulo, nosotros llegamos a seleccionar un médico aleatorio.

[01:37] Nosotros hicimos las validaciones de integridad para verificar que ese ID existiese en la base de datos y que no fuese nulo. Ahora vamos a realizar validaciones un poco más complejas que no podemos realizar con bin validation ni son validaciones tan simples como únicamente verificar si el ID es nulo.

[01:58] Entonces nosotros vamos a aplicar un design pattern, que nos va a permitir colocar todas esas clases de validación de forma más ordenada y más de más elegante. Y también va a permitir que esta clase siga creciendo y que a la hora de darle mantenimiento sea más complejo.

[02:22] Entonces, para eso nosotros vamos a crear dentro de la clase de consulta un paquete llamado validaciones y vamos a ver las reglas de negocio. La primera regla de negocio es el horario de atención de la clínica es de lunes a sábado de 7:00 a 19:00 de la tarde. Las consultas tienen duración fija de una hora.

[02:45] Entonces esa no es una validación que vamos a realizar dentro de nuestras validaciones, ya que eso queda fijado dentro de la información que se pasa al recibir los datos. Las consultas tienen que hacerse con al menos 30 minutos de anticipación. Eso está relacionado al momento en que se realiza la consulta, una validación.

[03:12] Tenemos que verificar que el paciente y que los médicos no se encuentren inactivos, que el médico no tenga ya una cita con otro paciente y que el paciente no realice más de una cita por día. Entonces vamos a hacer la primera validación que sería horario de funcionamiento.

[03:36] Entonces, para eso vamos a crear un método que se va a llamar público, va a ser un método público. Y va a enviar un mensaje, una excepción en caso de que sea verdadero. Entonces va a llamar validar y va a recibir los datos de la consulta. Entonces, lo que nosotros queremos hacer es verificar que no sea domingo, ya que el horario de atención de la clínica es de lunes a sábado, ni que se encuentre fuera del horario de atención que es de 7:00 de la mañana y 19:00 de la tarde.

[04:09] Vamos a crear una variable acá que se va a llamar domingo. Y vamos a utilizar de la clase DayOfWeek, la clase numeradora, vamos a verificar si eso es igual a la fecha datos.fecha, getDayOfWeek. Si eso se cumple, nosotros nos encontramos en el domingo.

[04:39] En caso de que sea domingo, enviamos un mensaje de error. Si domingo, si el valor de domingo es verdadero nosotros vamos a enviar una nueva excepción. No vamos a enviar validación integral ya que tenemos una validación de integridad, vamos a enviar una validación, una excepción. La excepción sería el horario de atención de la clínica que es de lunes a sábado de 7:00 a 19:00 horas.

[05:14] Como nosotros estamos viendo que la comparación entre domingo y la fecha de la consulta es igual, va a retornar un valor de true. Entonces nos encontramos en el domingo. Sin embargo, está faltando verificar el horario de apertura. Variable antes de la hora de apertura de hora de abrir antesDeApertura y lo siguiente, verificar despuesDeCierre.

[05:58] Si se encuentra después de la hora de cierre o antes de la hora de abrir, nosotros también vamos a enviar ese mensaje de error, para eso vamos a verificar la fecha de los datos, vamos a obtener la hora y vamos a verificar que sea menor a 7:00. El formato del localDateTime es un formato de 24 horas. Acá también vamos a tener la fecha, vamos a obtener la hora.

[06:32] Si es mayor a las 19:00 horas, que serían las 7:00 de la tarde entonces vamos a enviar ese mensaje de error. Entonces, antes de la apertura o después del horario de cierre. En caso de que esto se cumpla, enviamos el error. La siguiente condición es el horario de anticipación, las consultas deben programarse con al menos 30 minutos de anticipación más. Vamos a crear otra clase HorarioDeAnticipacion.

[07:07] Al igual que lo hicimos con la clase anterior, nosotros vamos a crear un cuerpo. De acá nosotros vamos a modificar las condiciones, solamente vamos a corregir el mensaje. Entonces, dentro de ese método yo tengo que verificar la hora en el momento en que se está realizando esa consulta y la hora en la que se está registrando la consulta.

[07:34] Si la diferencia es de menos de 30 minutos, entonces esa consulta no puede ser realizada. Entonces vamos a colocar, vamos a obtener el momento actual. Lo vamos a llamar ahora de la clase LocalDateTime.now. Y vamos a obtener la fecha: var horaDeConsulta.

[08:06] Si la hora de consulta, horaDeConsulta. Si la diferencia entre horaDeConsulta es de menos de 30 minutos, diferenciaDe30Min, entonces, esa consulta no puede ser realizada. Para eso vamos a utilizar Duration.between el momento ahora y la hora de la consulta. Entonces, en caso de que esto se cumpla, de que sea menor a 30 vamos a obtener los minutos, y en caso de que sea menor a 30 nosotros tenemos que enviar un mensaje indicando que esa consulta no puede ser realizada.

[09:02] Si la diferencia de minutos es verdadera, es decir, que es menor a 30, nosotros vamos a enviar un mensaje de error throw new ValidationException indicando que las consultas tienen que tener al menos 30 minutos de anticipación. Entonces, con eso ya tenemos la segunda validación.

[09:28] La siguiente validación es que no se pueden permitir agendar pacientes inactivos, vamos a crear otra clase que se va a llamar PacienteActivo. Ahora nosotros tenemos que verificar en la base de datos si el parámetro activo para ese paciente se encuentra como true o como false.

[09:58] En caso de que el parámetro activo se encuentre falso, nosotros tenemos que enviar un mensaje de error indicando que esa consulta no se puede realizar para ese paciente. Entonces lo primero que tenemos que hacer es verificar que el ID de ese paciente no sea nulo. Si el ID de ese paciente es igual a nulo, vamos a retornar.

[10:29] En caso de que no sea nulo, nosotros vamos a crear una variable llamada pacienteActivo y vamos a buscar en el repositorio. Para eso tengo que inyectar acá el repositorio, crear un parámetro privado PacienteRepository, vamos a llamar paciente y le voy a anotar con la anotación @Autowired, y aquí en el siguiente video vamos a inyectar estas validaciones dentro de la clase de servicio y les voy a mostrar cómo hacerlo. Por los momentos nosotros no vamos a utilizar la anotación @Autowired.






														03 Validación
														
Transcripción
[00:00] Entonces sí, nosotros necesitamos realizar una búsqueda en la base de datos, una búsqueda particular donde no vamos a traer todos los elementos del paciente, sino únicamente el parámetro activo, y el parámetro activo es buscando por el ID. Entonces vamos a realizar una consulta de la misma forma que lo hicimos para con el médico.

[00:26] Entonces, ahora sería acá findActivoById. Lo que voy a pasar acá sería el datos.idPaciente. Ahora, como ese método no existe, vamos a crear ese método dentro del pacienteRepository y vamos a crear una consulta. Esa query, de la misma forma que lo hicimos anteriormente, tenemos que tener tres comillas y vamos a seleccionar el parámetro activo from Paciente. Acá coloqué a m. Una p.

[01:19] Puede ser m también, pero vamos a colocar p, indicando que es de paciente. From Paciente where p.id= :idPaciente. Entonces, ya con esta consulta, nosotros vamos a estar recibiendo un parámetro booleano en pacienteActivo. Si pacienteActivo se encuentra activo, entonces nosotros podemos agendarlo.

[01:56] Entonces lo que nosotros queremos es que el paciente se encuentre inactivo para enviar un mensaje de error. Entonces si pacienteActivo es igual a falso, va a negar esa condición, enviamos un mensaje de error: throw new ValidationException. Vamos a enviar un mensaje. Entonces no se pueden permitir agenda. No permitir agenda, no se puede permitir agendar agendas citas con pacientes inactivos en el sistema. Perfecto.

[02:56] Para médicos se hace la misma variación. Lo voy a dejar como desafío para que ustedes lo hagan. Sin embargo, en el siguiente video ahí ya van a encontrar esa validación realizada. Sería bastante bueno que se desafíen a sí mismos para realizar esa validación y pensar un poco.

[03:17] Los va a ayudar bastante en su proceso de formación. La siguiente validación que vamos a hacer es que no se pueden permitir más consultas para pacientes en el día. Entonces, a esa nueva clase la vamos a llamar paciente sin consulta. PacienteSinConsulta. Entonces, para eso nosotros tenemos que verificar que ese paciente exista dentro del intervalo. En caso de que exista nosotros vamos a enviar un mensaje de error.

[04:02] Entonces lo primero que tenemos que hacer es crear nuestro método public void validar. Va a recibir los datos de la consulta. Vamos a crear nuestro método. Vamos a crear dos variables, uno que va a cumplir con el primer horario, indicando que el primer horario en el que ese paciente pueda asignar una nueva consulta, vamos a colocar acá primer horario. Para eso vamos a utilizar la fecha y vamos a modificarla al horario de las 7:00 de la mañana.

[04:51] Entonces sí, independientemente de la fecha que estemos recibido acá vamos a modificar a las 7:00 y vamos a ver el último horario, el último horario como la duración es de una hora, como último horario entonces de datos.fecha, tenemos que asignar esa fecha, datos withHour sería 18 horas.

[05:24] Entonces, ya con eso tenemos la fecha en la que el paciente puede asignar la consulta. Vamos a verificar pacienteConConsulta. Entonces, para eso yo necesito verificar si existe un id para ese paciente en la base de datos, con una fecha entre ese intervalo que sería las 7:00 y las 18:00 de la tarde. Entonces, para eso ya necesitamos inyectar el repositorio ya que voy a hacer una consulta, vamos a hacer private PacienteRepository y lo vamos a llamar repository.

[06:23] Entonces voy a utilizar el repositorio. Y acabo de utilizar el método existBy. Vamos a consultar. ¿Entonces, acá dónde tenemos que consultar? Aquí no tenemos que consultar en el repositorio de paciente. Acá tenemos que consultar en el repositorio de las consultas. Si existe una agenda ya para ese día con el id de ese paciente, dentro de ese intervalo, entonces nosotros no podemos permitir que se realice la consulta. Entonces acá vamos a modificarlo.

[07:00] ConsultaRepository. También se va a llamar Repository. ¿Entonces, qué es lo que vamos a verificar? Vamos a utilizar el patrón donde escribimos la consulta en inglés y dejamos a sprint realizar nuestra consulta SQL de forma automática. ¿Entonces qué vamos a colocar? existByPaciente ya que el parámetro que existe dentro de consulta es pacienteId. PacienteIdAndFechaBetween, y pasamos los parámetros.

[07:56] ¿Entonces, qué parámetros tenemos que indicar? Tenemos que indicar los datos, el idPaciente. La fecha de 7:00 horas, que sería primer horario y la última hora, el último horario. Entonces, si existe un paciente dentro del repositorio de consultas, si existe una agenda dentro del repositorio de consultas, nosotros tenemos que enviar un mensaje de error.

[08:28] Entonces acá vamos a colocar if(pacienteConsulta) es true, nosotros también vamos a enviar un error. Throw new ValidationException enviando un mensaje de error. Entonces acá este método no existe en el repositorio, tenemos que crearlo. Vamos a crear ese método en el repositorio de consulta.

[08:54] Y vemos que él está retornando void, es el método de tener que retornar un booleano. Y los parámetros de ese método, de la interface serían el ID del paciente, la fecha del primer horario y la fecha del último horario. Entonces vamos a verificar que en consulta nosotros estamos usando paciente_id y estamos utilizando datos, acá estamos, acá tenemos que cambiarlo de fecha a dato.

[09:35] Entonces vamos a crearlo de nuevo, vamos a corregirlo acá en el ConsultaRepository. Acá sería dsto. Vamos a colocar dato. Se ha corregido el error. Ahora están faltando médico activo y paciente con fecha. Médico con otra consulta. Entonces, para el caso del médico, vamos a iniciar el médico, lo vamos a dar para que lo finalice.

[10:17] Entonces sería MédicoConConsulta. Nosotros tenemos que hacer de la misma forma que hicimos con PacienteSinConsulta. Entonces vamos a verificar, vamos a crear nuestro método público, voy a enviar un mensaje, voy a llamar validar DatosAgendarConsulta y acá hicimos en PacientesSinConsulta, nosotros tomamos el horario, creamos el método existsByPacienteIdAndDataBetween.

[11:08] En caso de que sea verdad, tenemos que enviar un mensaje de error que sería “el paciente ya tiene una consulta para ese día”. Entonces, acá en MedicoConConsulta hay que inyectar el repositorio. Sería private. Vamos a realizar una consulta. ConsultaRepository. Vamos a llamar repositorio y vamos a hacer ese chequeo dentro de nuestro método.

[11:57] Entonces tenemos que verificar una variable para MédicoConConsulta. Vamos a llamar en el repositorio, entonces sería existByMedicoIdAndData. Entonces acabamos de pasar datos, el id del médico. Y vamos a pasar de los datos la fecha. Vamos a crear este método que va a retornar también un booleano.

[13:03] Entonces ya tenemos existByMedicoIdAndData, damos id acá con MédicosConConsulta. Y de la misma forma que nosotros hicimos, tenemos que validar que ese ID no sea nulo. Entonces acá teníamos que hacer if(datos.idMedico)==null return, caso que no sea contrario sigue con el nulo.

[13:36] Si medicoConConsulta es true, nosotros estamos retornando ahora un booleano, vamos a enviar un mensaje de error: throw new ValidationException. Vamos enviar un mensaje de error indicando “este médico ya tiene una consulta en ese horario”. Nosotros estamos pasando la fecha en la que se va a realizar esa consulta.

[14:12] Va a verificar esa fecha dentro de su programa de consulta y si consigue conseguir el ID del médico, va a conseguir que encuentre otra fecha. En caso de que eso se cumple, es porque ese paciente, este médico está trabajando con otro paciente.

[14:28] Entonces tiene que retornar un mensaje de error. El único método que nos está faltando acá es el de MédicoActivo, lo vamos a dejar como desafío. Sin embargo, en el próximo video lo van a encontrar ya resuelto. Es igual que PacienteActivo, simplemente vamos a cambiar los datos a MédicoActivo.

[14:53] Entonces. Intentan realizarlo sin ver el ejercicio, simplemente pensando, para que vean dónde se están equivocando y lo puedan desarrollar sus habilidades de pensamiento.





														04 Aplicando principios SOLID
														
Transcripción
[00:00] Hola, ya en la clase anterior, nosotros desarrollamos todo lo que serían los validadores que nos van a permitir registrar en la base de datos nuevas consultas que cumplan con las reglas de negocio de la clínica.

[00:12] Ahora nosotros tendríamos que instanciar en teoría cada una de esas clases, y pasar el parámetro datos al método validar que se encuentra dentro de la clase para poder validar, para realizar esas validaciones de las reglas de negocio.

[00:28] Pero de esa forma no es la forma más adecuada, no sería una buena forma, ya que a la hora de que nosotros tengamos que eliminar alguna de esas validaciones, porque ya no tiene sentido dentro del negocio, nosotros tendríamos que ir a eliminar esa clase, ese validador y luego venir a la clase de servicio, intervenir dentro de la clase de servicio y modificarlo, eliminando ese atributo, ese parámetro que estamos instanciando.

[01:03] Entonces nosotros vamos a mostrar acá un método que nos va a permitir seguir los principios solid, el pilar de polimorfismo que nos va a permitir adaptar una interface a múltiples finalidades, y va a dejar nuestro código con la mejor presentación posible.

[01:28] Entonces, si nosotros vemos cada uno de esos validadores, ellos tienen algo en común. La clase HorarioDeAnticipación tiene una firma que es pública, retorna un elemento del tipo void, o sea no retorna nada. El nombre es validar, y va a recibir como parámetro un elemento llamado datos del tipo DatosAgendarConsulta.

[01:51] Eso se cumple para HorarioDeFuncionamientoClinica. Se cumple para MedicoActivo. Tiene el método público, se llama validar, nos retorna nada y recibe un único parámetro. A pesar de que tiene un atributo, el método y la firma es la misma que la de las anteriores. MédicoConConsulta también cumple esa firma.

[02:16] PacienteActivo y PacienteSinConsulta. Entonces lo único que va a modificar es el atributo que se encuentra dentro de alguna de las clases. Pero existe una estrategia, un recurso que nosotros podemos implementar dentro de Java que son las interfaces, donde nosotros tenemos múltiples clases que implementan el mismo método con la misma firma, una misma funcionalidad.

[02:48] Nosotros podemos crear una interface para indicarle a los desarrolladores que eso va a hacer un patrón que se debe seguir. Entonces nosotros vamos a crear una clase, a hacer una interface y la vamos a llamar validador de consultas. Entonces, de esta forma, nosotros le indicamos a los desarrolladores que tienen que seguir un patrón que cumpla con esa firma.

[03:20] Entonces dentro de las interfaces nosotros vamos a colocar métodos abstractos. La interface es una clase abstracta que son métodos que no tienen cuerpo, simplemente sirven para indicar cuál va a ser la firma de los métodos que van a ser implementados dentro de las clases que implementen en esa interface.

[03:42] Entonces nosotros, ya como ya veríamos verificado la firma de cada una de esas clases es esta. Yo voy a copiar acá ese método y de la interface validadorDeConsultas y lo voy a copiar acá. Ya con eso tengo asignado el método que yo deseo implementar dentro de cada uno de esos validadores.

[04:09] Para yo conseguir implementar esta interface dentro de cada una de las clases voy a ir a cada uno de los validadores, voy a colocar la palabra implements y voy a colocar el validador de consulta. Entonces como vemos ya se está implementando el validador de consultas dentro de la interface, aquí voy a eliminar esto temporalmente.

[04:33] Si nosotros no colocamos el método, él automáticamente nos genera un error y nos dice que se tienen que implementar los métodos que se encuentran dentro de la interface.

[04:45] Como ese método ya estaba elaborado, simplemente voy a dejar el método con el cuerpo y así nosotros cumplimos con el pilar de polimorfismo que es uno de los pilares de Java de programación orientada a objetos que nos indica que nosotros podemos utilizar un mismo método, con diferentes funciones.

[05:10] Entonces, por ejemplo, en el horario de anticipación nosotros, el método de validarConsulta o validar verifica que la agenda de esa consulta sea 30 minutos antes. Pero dentro de la clase horario de funcionamiento de la clínica al yo implementar el validador de consulta, ahora ese método validar está proviniendo de la interface, él va a tener otra función, otra finalidad, que es verificar que la consulta no se esté realizando fuera del horario permitido.

[05:50] Entonces, nosotros vamos a hacer lo mismo con MédicoActivo, vamos a implementar la interface ValidadorDeConsultas, que se encuentra operativa. Entonces vemos como el polimorfismo va a adaptarse a cada una de las finalidades de la clase. MédicoConConsulta vamos a implementar ValidadorDeConsultas.

[06:21] En paciente activo también vamos a hacer lo mismo, implementar ValidadorDeConsultas, y por último, en PacienteSinConsulta. Entonces, a la hora de que una persona quiera ingresar un nuevo validador simplemente tendría que cumplir con esa norma, con ese patrón para crear la clase y va a implementar esa interfaz automáticamente la interfaz le va a indicar que tiene que implementar un método que va a ser el método validar.

[06:56] Entonces el polimorfismo se va a encargar de asignar la diferencia entre esa nueva clase y los validadores que ya se encuentran funcionando. Entonces, ahora nosotros tenemos que colocar una anotación de sprint que le va a indicar a nuestro proyecto que ya esa clase se encuentra operativa, de otra forma no es conocida dentro del proyecto.

[07:24] De esta forma, sin ninguna anotación, el proyecto no sabe que existe. Nosotros tendríamos que instanciarla dentro de la clase de servicios utilizando la palabra new HorarioDeAnticipación. Pero Spring nos permite utilizar las anotaciones. Esta no es una clase de controlador, tampoco es una clase de servicio, ni tampoco es un repositorio.

[07:46] Entonces nosotros habíamos mencionado que teníamos la clase component, es que es la clase de anotación raíz de la que derivan los servicios, los repositorios y los controladores. Entonces yo voy a anotar la clase pacienteSinConsulta como un componente y voy a inyectar el repositorio con la anotación @Autowired.

[08:10] Entonces, ahora Spring sabe que el repositorio de consulta se debe inyectar dentro de la clase de pacienteSinConsulta, y sabe que esta clase de pacienteSinConsulta se encuentra disponible donde quiera ser inyectada, que nosotros la vamos a inyectar dentro de la clase de servicio. Entonces vamos a colocar el resto de las anotaciones.

[08:30] Vamos a colocar @Autowired y la anotación @Component. En MédicoConConsulta también vamos a colocar la notación @Component para indicar que se encuentra disponible dentro de nuestro proyecto la anotación @Autowired de la consulta de MédicoConConsulta, entonces siempre que nosotros estemos tengamos que indicar dónde se va a inyectar una clase que está siendo auto instanciada por Spring, nosotros utilizamos la anotación @Autowired.

[09:05] Y cuando queramos auto instanciar una clase, nosotros tenemos que verificar cuál es la finalidad de esa clase, en este caso es un componente simple, podríamos utilizar la clase @Service y él ya funcionaría de la misma forma, ya que también de un cierto modo es un servicio, al realizar un servicio de validar consulta. Vamos a dejar esta clase acá como @Service.

[09:34] Voy a eliminar este espacio. Y voy a colocar el restante @Component. Acá también @Component. Entonces, de esta forma ya todas las clases se encuentran operativas dentro del proyecto. Tengo que ir a mi clase de servicio, e indicarle que yo quiero usar cada una de esas clases que ya se encuentran instancias dentro de la clase de servicio.

[10:02] Entonces, lo primero que se nos viene a la mente es asignar un atributo del tipo de horarioDeAnticipación y colocar la anotación @Autowired que sería privado, horarioDeAnticipación, colocar el nombre del atributo y colocar la anotación @Autowired.

[10:23] Ahí nosotros tendríamos que hacer eso con cada una de las clases y a la hora que nosotros deseemos modificarlo, tendríamos que eliminar el atributo y la clase. Entonces nuevamente estamos violando el principio de modificación de open close. Entonces, lo que nosotros vamos a crear es una especie similar al Design Pattern Strategy.

[10:50] Vamos a crear un atributo que Spring nos permite utilizar, que es nNosotros vamos a crear una lista que va a recibir un elemento del tipo ValidadorDeConsulta. Esa lista la vamos a llamar validadores. Entonces, de esta forma, nosotros simplemente tenemos una lista, una lista que está recibiendo una interfaz.

[11:22] Pero cuando yo coloco acá la anotación @Autowired, Spring automáticamente sabe que todos los elementos que estén implementando la interfaz ValidadorDeConsultas van a ser inyectados dentro de esta lista y van a encontrarse disponibles.

[11:41] De esa forma cuando se agreguen nuevas validaciones o se elimine alguna de esas validaciones, nosotros no tendríamos que intervenir dentro de la clase de servicio, sino simplemente eliminar esa clase y Spring automáticamente sabe que ya esa clase no existe dentro de la lista.

[12:02] Entonces, nosotros podríamos agregar 100 clases, eliminar 15 clases y no tendríamos que llevar un registro de cuáles clases tenemos que alterar dentro de mi clase de servicio. Entonces, ya esta clase se encuentra cerrada para modificación y nos permite crear extensiones para esos validadores.

[12:23] Otro principio que nosotros estamos creando es el principio de la S, de single responsabilty. Nosotros tenemos una única responsabilidad para la clase de servicio, que es revisar, recibir ese parámetro y realizar esa consulta y cada una de esas clases tiene una única función que es recibir el parámetro y validar.

[12:50] Esta clase que es la clase horarioDeFuncionamiento también tiene una única función, valida el HorarioDeFuncionamientoClínica. MedicoActivo chequea si ese médico se encuentra activo. Entonces nosotros estamos asignando una única responsabilidad para cada una de esas clases.

[13:12] Y el siguiente principio que nosotros estamos utilizando dentro de nuestro proyecto es el principio de inversión de dependencias, que nos indica que las clases, las clases de alto nivel tienen que depender de abstracciones o interfaces y no de clases de bajo nivel.

[13:32] Entonces para eso es importante saber que las clases de alto nivel son las clases que se encuentran directamente relacionadas con las reglas de negocio. Entonces esas clases que se encargan de buscar la consulta, que una clase que se encargue de guardar una consulta, de buscar alguna de las consultas o de asignar nuevas consultas por id, esas clases van a estar asociadas directamente con las reglas de negocio.

[14:00] Ahora las clases que estén asociadas van a hacer clases de alto nivel porque se encuentran relacionadas con las reglas de negocio. Y las clases que son de bajo nivel son clases que se encargan de realizar conexiones. Entonces nosotros no podemos colocar estas clases de alto nivel dependiendo de validación.

[14:20] Nosotros las tenemos que colocar que dependan de interfaces o abstracción. De esa forma nosotros a la hora de realizar una modificación, nosotros no tenemos que intervenir dentro de nuestra clase, sino eliminar, seleccionar cuál es el elemento que nosotros deseamos eliminar y modificar algún elemento dentro de la interfaz.

[14:52] Entonces, ya con eso, nosotros tenemos nuestro parámetro funcionando dentro de la clase de servicio, ahora simplemente tenemos que pasar los parámetros. Para pasarle ese parámetro, vamos a colocar el atributo validadores. Vamos a aplicar un forEach para recorrer todos los elementos que se encuentran dentro de esa lista.

[15:15] Entonces esa lista va a estar conformada por cada uno de los validadores que nosotros creamos y vamos a utilizar un arrow function para utilizar el método validar pasándole los datos que estamos recibiendo como parámetro.

[15:30] Entonces si vemos él automáticamente se encarga de enviar esos datos a cada uno de esos validadores y verificar si cumple con las condiciones deseadas para la clínica. Entonces, se cumplen los principios solid, estamos siguiendo el pilar de polimorfismo y ya creamos nuestra clase de servicio, que nos permite agendar un registro en la base de datos que cumple con las normas de HorarioDeAnticipación, HorarioDeFuncionamiento de la clínica o MedicoActivo, etcétera.

[16:10] Entonces solamente nos está faltando testar este proyecto hasta este punto. Lo vamos a hacer en la siguiente parte utilizando la API de Postman.




														 05 Para saber más: principios SOLID
PRÓXIMA ACTIVIDAD

SOLID es un acrónimo que representa cinco principios de programación:

Principio de Responsabilidad Única (Single Responsibility Principle)
Principio Abierto-Cerrado (Open-Closed Principle)
Principio de Sustitución de Liskov (Liskov Substitution Principle)
Principio de Segregación de Interfaces (Interface Segregation Principle)
Principio de Inversión de Dependencia (Dependency Inversion Principle)
Cada principio representa una buena práctica de programación que, cuando se aplica en una aplicación, facilita mucho su mantenimiento y extensión. Estos principios fueron creados por Robert Martin, conocido como Uncle Bob, en su artículo Design Principles and Design Patterns.







															06 Testando la agenda
															
Transcripción
[00:00] Hola. En la parte anterior, nosotros implementamos las validaciones dentro de la clase de servicio, ahora vamos a verificar que estén funcionando correctamente y posteriormente vamos a aprobar cada uno de los casos dentro de la API de Postman.

[00:14] Entonces, cuando nosotros realizamos la clase de servicio, hubo un pequeño error que cometí. Si nosotros analizamos detenidamente, nosotros estamos recibiendo los datos dentro de la clase de servicio en el método de agendar y la primera condición que nos encontramos es vamos a hacer una consulta en la base de datos para el paciente y en caso de que el ID para ese paciente se encuentre, nosotros vamos a enviar un mensaje de error.

[00:45] Entonces eso no es lo correcto. Lo correcto sería enviar un mensaje de error en caso de que no sea encontrado el ID. Para eso vamos a utilizar el signo de interrogación para negar esa condición. De la misma forma, con el repositorio de médicos, en caso de que exista el ID para ese médico, nosotros estamos arrojando una excepción y lo correcto es en caso de que no exista ese ID, enviar ese mensaje de error.

[01:14] Ya hemos corregido el primer error, ahora vamos a ejecutar la aplicación para ver dónde se encuentran los otros errores que hemos detectado en la aplicación. Al intentar ejecutar la aplicación, vemos que en la clase de repositorio de médicos el ID no fue encontrado. Si vamos al repositorio de médico, vemos que nosotros copiamos este método del repositorio de paciente.

[01:42] Lo correcto es podríamos haberlo copiado. El tema es que pasar el parámetro correcto que sería algo así como idMédico y tenemos que colocarlo en el lado derecho de la consulta. El lado izquierdo corresponde al atributo de la clase médica. Entonces, si acá colocamos algo como ids entonces tenemos que indicar que acá también tendría que tener la s.

[02:12] En este caso, vamos a dejarlo cómo está. De verdad vamos a ejecutar la aplicación nuevamente. Ahora nos encontramos que cuando estaba intentando realizar la consulta en el repositorio de consultas, se encontró que la propiedad existByPacienteId no existía.

[02:36] Entonces el JPA de Spring framework tiene su patrón de búsqueda en inglés y una simple letra puede representar un error a la hora de ejecutar nuestra aplicación, entonces lo correcto sería exists, con s, ByMedicoId. Entonces, si nosotros nos equivocamos con una letra, vamos a recibir un error a la hora de ejecutar nuestra aplicación.

[03:05] Entonces de la forma correcta, vamos a ir donde se encuentran aplicados estos métodos. Vamos a ir a la clase ConsultaRepository. Acá este se encuentra en MédicoConConsulta. Vamos a intentar ejecutar la aplicación nuevamente. Luego de haber ejecutado nuestra aplicación y estar corriendo exitosamente, vamos a ir a nuestra tarjeta de Trello para verificar cada uno de los casos de las reglas de negocio.

[03:42] Ya con la aplicación corriendo en el puerto 8080, vamos a verificar cada una de las reglas de negocio. Entonces las primeras reglas de negocio que tenemos que verificar es que el id del paciente y el del médico existan, también vamos a verificar que el horario en el que se está intentando realizar la consulta se encuentren dentro del intervalo de funcionamiento.

[04:03] Entonces, si intentamos realizar esa consulta, por ejemplo el día domingo, nos vamos a encontrar con un error o si lo intentamos realizar a las 6:00 de la mañana también debería arrojarnos un error. Vamos a intentar realizar consultas con pacientes inactivos, con médicos inactivos y con médicos que ya tengan un paciente para ese horario, así como pacientes que ya tengan una consulta asignada para ese día.

[04:31] Entonces vamos a ir a la aplicación de Postman. Vamos a comenzar a probar cada uno de esos casos. Vamos a ejecutar. Entonces nos encontramos con el estado 403. Es que nosotros no hemos enviado la autorización. Recordamos que tenemos que recibir primero el token, vamos a ir a la clase de login y vamos a enviar la clave.

[04:54] Entonces Spring hace la transformación de este número con encriptado decrypt y recibimos el token luego de haber procesado la información. Vamos a copiar ese token, vamos a ir a la requisición de consulta y en la requisición, vamos a ir a autorización, vamos a colocar el token y en el cuerpo vamos a intentar enviar estos valores nuevamente.

[05:24] Entonces no estamos recibiendo ningún error. Vamos a ir a la aplicación y tenemos el siguiente mensaje de error. El mensaje nos indica que el ID para el paciente no fue encontrado. Para nosotros recibir ese mensaje de error dentro de la API de Postman, tenemos que ir a la infra en el tratador de errores y vamos a copiar de acá esta última sección.

[05:54] Vamos a colocar error, un nombre para esta aplicación, errorHandlerValidacionesDeNegocio. El error que nosotros estamos recibiendo es la validación de integridad. Además de la validación de integridad, tenemos que colocarla, vamos a pasar como el atributo Exception. Vamos a eliminar esta línea y vamos a colocar la validación de integridad.

[06:36] ValidacióndeIntegridad. Acá tenemos que enviar el mensaje en el cuerpo de la aplicación y vamos a ejecutar esta aplicación nuevamente. La detenemos. Ya con la aplicación corriendo de nuevo en el puerto 8080, vamos a ir a la aplicación de Postman y vamos a intentar ejecutar la petición de nuevo.

[07:07] Entonces, vemos que estamos recibiendo “este id para el paciente no fue encontrado”. O sea, ya estamos tratando ese mensaje de error. Lo siguiente, vamos a colocar el ID número 1, vamos a colocar un médico que no existe. Nuevamente “el id para ese médico no fue encontrado”.

[07:28] Ahora vamos a colocar una consulta con el id de paciente número 1 y el id médico número 1. Entonces, nosotros estamos recibiendo aún ese primer mensaje que configuramos al inicio del curso donde estamos recibiendo el ID de pacientes todos nulos. Vamos a ir a la aplicación. Y dentro de la aplicación nosotros vamos a ir al controlador donde se encuentra ese retorno.

[08:06] Acá, nosotros vamos a asignar el retorno de ese servicio a una variable que sería response. El nombre de esa variable va a ser la respuesta que la vamos a enviar dentro del cuerpo del ResponseEntity. La vamos a llamar response. Ahora voy a ir a la clase de servicio AgendaDeConsultaService y tengo que asignarle un retorno a ese método.

[08:38] El retorno para ese método va a ser nuevo agenda, va a ser DatosDetalleConsulta. Y luego el detalle de la consulta va a ser esa consulta que estamos creando. Acá sería consulta. No tenemos un constructor dentro de la clase de consulta dentro del record consulta y vamos a crearlo, entonces tenemos que crear el constructor y dentro, vamos a colocar this y vamos a pasar cada uno de los parámetros.

[09:25] Entonces el primer parámetro sería consulta.getId. El siguiente, consulta.getPaciente. Vamos a obtener el ID para el paciente, también vamos a obtener el ID del médico. Y por último, la fecha en la que se realizó esta consulta. De esa forma, vamos a colocar punto y coma. Aquí tenemos que cambiar el retorno, "Ctrl + V". Vamos a cambiar el retorno de void a DetalleConsulta y ya tenemos el controlador enviando el mensaje con los datos de esa consulta.

[10:24] Vamos a ejecutarla de nuevo. Esa última consulta que nosotros realizamos con el ID de paciente número 1 y el ID del médico número 1 fue realizada exitosamente, ahora nosotros vamos a intentar realizar una consulta con el ID de paciente número 4, número 3, por ejemplo. Y el ID de México número 4.

[10:53] Vamos a enviar la petición. Y vemos que fue asignada una consulta con ID número 6, el ID de paciente 3 y la fecha en la que se realizó esta consulta. Ahora en las tarjetas de Trello vamos a comenzar a probar los casos de las reglas de negocio. Vamos a probar estos dos casos de acá. Son los casos más simples.

[11:17] El caso en el que tenemos un paciente inactivo y un médico inactivo. Entonces yo sé ya por referencia de que el paciente número 2 se encuentra inactivo. Entonces no estamos recibiendo un mensaje de error, vamos a ir a la aplicación a ver qué está sucediendo.

[11:39] Entonces, acá yo tengo lo siguiente. Ahora yo tengo que este médico ya tiene una consulta de horario, ¿pero por qué no estamos recibiendo un error para esa consulta? El error que nosotros tratamos en la parte anterior fue el error de validación de integridad y este error se llama ValidationException.

[12:07] Entonces yo tendría que crear otro método error que va a contener esa clase. Entonces voy a copiar esa clase que sería la ValidationException. Voy a pegarla acá y voy a importar esa clase. Acá tengo que cambiar errorHandlerValidaciones. Acá vamos a cambiar, dejar estas validaciones de negocio aquí, validaciones de integridad.

[12:46] Pero nuevamente con la aplicación corriendo en el puerto 8080 vamos a ir a la aplicación de Postman y vamos a intentar agendar una consulta con el médico, por ejemplo médico 3. Y el paciente que sabemos que se encuentra inactivo el número 2. hacemos una petición. Y sé que no se puede permitir agendar citas con pacientes inactivos.

[13:08] También sabemos que el médico con ID 5 se encuentra inactivo, entonces vamos a hacer una petición para hacer agendar esa consulta y sé que no se pueden permitir agendar citas con médicos inactivos. Ese médico se encuentra inactivo y el paciente de ID número 2 también se encuentra inactivo.

[13:30] Al inicio nosotros realizamos una consulta para el médico de ID 1 y el médico de ID número 4. Ambos médicos son de ortopedia. Ahora vamos a intentar realizar una consulta para el paciente con el ID 3 y el médico con ID número 1 a ver qué sucede. Ese médico ya tiene una consulta en ese horario y el médico 4 también tiene una consulta en ese horario.

[13:59] Entonces nosotros no vamos a llenar ese campo, y sé que el paciente ya tiene una consulta para ese día. Vamos a variar acá el paciente, vamos a colocar el paciente número 5. Entonces, debe seleccionarse una especialidad para ese médico. Podría colocar acá IdMedico y dejar el campo vacío. Entonces, de igual forma, dice que debe seleccionarse un ID para ese médico, una especialidad.

[14:35] Entonces vamos a colocar acá la especialidad, yo sé que para esos dos médicos que quería seleccionar eran del área de ortopedia, “especialidad: ORTOPEDIA”. Como yo estoy tratando esas especialidades con un enumerador, tengo que recordar pasar el nombre de la especialidad de la misma forma en que se encuentra en el numerador o dar un tratamiento para ignorarla si se encuentra en mayúsculas o minúsculas.

[15:12] Entonces acá voy a intentar realizar una consulta para ortopedia y para el ID número 5. No estamos recibiendo ningún mensaje, vamos a ir a la aplicación y ver qué está sucediendo. En la aplicación estamos recibiendo un mensaje de error. El mensaje de error indica que ese ID no puede ser null. ¿Entonces, qué es lo que estaba pasando?

[15:33] Nosotros estamos recibiendo los datos. El ID del paciente que tiene que encontrarse se encuentra, él continúa realiza las validaciones. Busca un paciente con ese ID. Como no tenía, el ID del médico se encontraba nulo, él intenta seleccionar un médico aleatorio, con los datos que fueron enviados, que sería la especialidad. Y como no encontró un médico disponible para ese horario, el médico, este valor de médico se encuentra nulo.

[16:13] Entonces nosotros tenemos que dar un tratamiento de error en caso de que ningún médico se encuentre disponible, que lo vamos a saber con el retorno de médico aleatorio que va a ser null. Entonces vamos a copiar de acá esta condición y luego de haber consultado si existe un médico aleatorio disponible nosotros vamos a modificar esta consulta y colocar: if(medico==null) nosotros vamos a enviar un error diciendo “no existen médicos disponibles para este horario y especialidad”.

[17:01] Vamos a ejecutar nuestra aplicación nuevamente. Ya con la aplicación corriendo vamos a ir a la aplicación de Postman y vamos a intentar realizar esta petición de nuevo. Vemos que no existen médicos disponibles para este horario y especialidad. Entonces podemos cambiar la especialidad de algunas de las especialidades disponibles.

[17:26] Vamos a revisar acá las especialidades. En las especialidades disponibles yo, vamos a revisar las especialidades? Vamos a intentar cardiología. En cardiología vamos a moverlo acá. Entonces vemos que conseguimos reagendar una consulta para el paciente número 5 en este horario, en la especialidad de cardiología.

[17:58] Vamos a intentar realizar otra consulta con otro médico en ese mismo día, ahora vamos a intentar con el paciente de ID número 5 y con pediatría. Entonces, vamos a intentar acá modificar por pediatría. Y dice que el paciente ya tiene una consulta para ese día.

[18:24] Entonces ya hemos probado el caso en el que no se permite programar más de una consulta el mismo día para el mismo paciente, cuando intentamos agendar una consulta de cardiología a pediatría. Tampoco podemos programar una cita para un médico que ya tiene otra cita programada en la misma fecha.

[18:49] Verificamos la regla en la que la opción del médico es aleatoria, verificamos también la regla del horario del intervalo de funcionamiento de la clínica y de que el ID exista enviar un mensaje de error. La validación de 30 minutos de anticipación por el horario en el que se está realizando este video no la vamos a poder realizar, vamos a dejarlo como ejercicio.

[19:17] Y también vamos a dejar como ejercicio la actividad de cancelamiento de consulta, entonces con las herramientas que ya hemos dado hasta este punto podemos realizar el caso en cancelamiento de consulta. Sin embargo, en la siguiente parte ustedes van a encontrar esta actividad ya resuelta.

[19:35] Sin embargo, recomendamos altamente que realicen ese desafío e intenten utilizar los métodos, los repositorios y el servicio que ya se colocó para aplicar el cancelamiento de consulta.







															 09 Lo que aprendimos
PRÓXIMA ACTIVIDAD

Lo que aprendimos en esta aula:

Aislar los códigos de validación de reglas comerciales en clases separadas, utilizando la anotación @Component de Spring;
Finalizar la implementación del algoritmo de programación de consultas;
Usar los principios SOLID para hacer que el código de la funcionalidad de programación de citas sea más fácil de entender, evolucionar y probar.






