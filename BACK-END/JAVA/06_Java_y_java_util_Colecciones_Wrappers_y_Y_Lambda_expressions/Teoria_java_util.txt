


///////////////////////////////////////////////////////////////////////////////////////////////////////	
								Paquetes en Java
								
								
								
								java.lang java.util  java.io
								
java.lang no es necesario importar por que es la base de todo el lenguaje

java.util es java son llamados los utilitarios, son estructura de datos, son objectos que nos
van a simplificar un poco la vida para realizar diferentes operaciones

							
					
					
					
///////////////////////////////////////////////////////////////////////////////////////////////////////	
								Arrays en Java
									
Siempre los array inician el indice en 0 y hay que declarar el tamanio del array sino
no compila


Por ejemplo






package com.bytebank.test;

public class TestMain {

	public static void main(String[] args) {
		
		
		 int[] edades=new int[5];
		 edades[2]=30;
		 
		 System.out.println(edades[2]);
		 
		 for(int i=0;i<edades.length;i++) {
			 
			 System.out.println(edades[i]);//*
		 }
		 
		 
		
	}
	
	
}										
										
					*Si pongo la i sin edades[i] va a mostrar el recorrido del for
					del 1 al 5 pero no sus valores			
					
					
					Crear un array de tipo doble
					
					double[] precios = new double[5];
					
					
					Existe otra alternativa menos utilizada pero igualmente correcta
					double precios[] = new double[5];	
					
					
					se puede saber el tamanio del array
					
					
					int tamnioarray= edades.leng;
					
					system.out.line(tamanioarray);
					
					
					
					
					
					
					
					/////////////////////////////////////////////////////
					
Hasta ahora hemos visto la forma "clásica" de crear un objeto 
array utilizando la palabra clave new, por ejemplo:
										
										
															
	int[] numeros = new int[6];
	numeros[0] = 1;
	numeros[1] = 2;
	numeros[2] = 3;
	numeros[3] = 4;
	numeros[4] = 5;				
										


Sin embargo, también existe una forma literal. Literal, en este contexto, significa usar valores directamente,
 menos burocrático, más directo. Vea la diferencia:			
 



			int[] refs = {1,2,3,4,5};				
			
				
			
Usamos las llaves {} para indicar que es un array y los valores ya están		
declarados dentro de las llaves.






					/////////////////////////////////////////////////////
					
									CASTING
									
hacer que ub objeto se convierta en otro, que tenga sentido obviamente 


		CuentaCorriente	corriente=new CuentaCorriente(23, 44);
		
		CuentaAhorros ca=new CuentaAhorros(2, 22);
		
		
		Cuenta[] cuentas=new Cuenta[5];
		
		cuentas[1]=corriente;
		cuentas[2]=ca;

		
		cuentas[0]=new CuentaCorriente(32, 12);
		

		//obtener una cuenta del array
		
		//CuentaCorriente cuenta=cuentas[1]; //no compila por que cuentas[1] hace referencia
//		al array de tipo cuentas, que esta mas arriba y es mas absorbente, no es de tipo cuentaCorriente
//			
//		LA SOLUCION ES HACER CAST
		
		CuentaCorriente cuenta= (CuentaCorriente)cuentas[1]; 
		//estoy diciendole a java que este objecto cuenta es una cuenta corriente entonces ahora si
		//compila
		System.out.println(cuenta);
		
		
		
									/////////////////////////////////////////////////////
					QUE TENGA SENTIDO NOS REFERIMOS A ESTO
					
					
					
						CuentaAhorros cuenta= (CuentaAhorros)cuentas[1]; 
						
						
						
						tira una exception uncheck por que por mas que las dos sean cuentas y que tienen
						a Cuenta como padre, las dos cuentaCorriente y cuentaAhorro son dos objectos diferentes
						hay diferencias entre las dos entonces solo puede ser cast a cuentaCorriente por que
						fue creada como cuentaCorriente












///////////////////////////////////////////////////////////////////////////////////////////////////////	
								Operaciones de Arrays en Java
										
										
					
public class GuardaCuentas {
	
	
	//Crear un objeto para guardar muchas cuentas
	//permitirnos agregar cuentas con un metodo
	//guardarCeuntas.adiciona(cuenta);
	//obtener.remover,etc.
	
	Cuenta[] cuenta=new Cuenta[10];

	int indice=0;
	
	public void adicionar(Cuenta cc) {
		// TODO Auto-generated method stub
		
		cuenta[indice]=cc;
		indice++;
		
	}

	public void obtener(int indice) {
		// TODO Auto-generated method stub
		
		System.out.println(cuenta[indice]);
		
	}

}
					
					
					
					
					
					
					test 
					
					
					package com.bytebank.test;

import com.bytebank.modelo.Cuenta;
import com.bytebank.modelo.CuentaAhorros;
import com.bytebank.modelo.CuentaCorriente;
import com.bytebank.modelo.GuardaCuentas;

public class TestGuardaCuenta {

	public static void main(String[] args) {
		GuardaCuentas guardarCuenta=new GuardaCuentas();
		
		Cuenta cc=new CuentaCorriente(1, 2);
		Cuenta ca=new CuentaAhorros(10, 20);
		
		//adicionar
		guardarCuenta.adicionar(cc);
		guardarCuenta.adicionar(ca);
		
		
		//Obtener
		guardarCuenta.obtener(0);
		guardarCuenta.obtener(1);
		
		
		
		
	}
}
										
										

///////////////////////////////////////////////////////////////////////////////////////////////////////	
								Paquete Java.util en Java
										
	ARRAYLIST
	
	el metodo size() de un arraylist nos dice cuantos elementos tiene, no el tamnio de array
	por que cuando usamos arrayList no nos interesa el tamanio
	
	
	
	
	se creo el array de tipo Object
	
	package com.bytebank.modelo;

public class GuardaCuentas {
	
	
	//Crear un objeto para guardar muchas cuentas
	//permitirnos agregar cuentas con un metodo
	//guardarCeuntas.adiciona(cuenta);
	//obtener.remover,etc.
	
	Object[] cuenta=new Object[10];

	int indice=0;
	
	public void adicionar(Cuenta cc) {
		// TODO Auto-generated method stub
		
		cuenta[indice]=cc;
		indice++;
		
	}

	public void obtener(int indice) {
		// TODO Auto-generated method stub
		
		System.out.println(cuenta[indice]);
		
	}

}
	
	
	
	
	
	test
	
	
	
	
	
	package com.bytebank.test;

import java.util.ArrayList;

import com.bytebank.modelo.Cuenta;
import com.bytebank.modelo.CuentaCorriente;

public class TestArrayList {

	
	public static void main(String[] args) {
		
		ArrayList lista=new ArrayList();
		
		Cuenta cc=new CuentaCorriente(10, 20);
		Cuenta c2=new CuentaCorriente(20, 30);
		
		
		lista.add(cc);
		lista.add(c2);
		
		Cuenta obtenerCuenta=(Cuenta) lista.get(0);
		System.out.println(obtenerCuenta);
	}
	
}
	
	
	
			
					/////////////////////////////////////////////////////
					
									ArrayList<E>
									
Podemos definir una lista con ArrayList pero a la hora de mostrar esa lista, nos va a pedir cast
ya que si definimos sin el valor generic <E> nos acepta add(agregar) pero no define que tipo espera
recibir


package com.bytebank.test;

import java.util.ArrayList;

import com.bytebank.modelo.Cuenta;
import com.bytebank.modelo.CuentaCorriente;

public class TestArrayList {

	
	public static void main(String[] args) {
		
		ArrayList<Cuenta> lista=new ArrayList<Cuenta>();
		
		Cuenta cc=new CuentaCorriente(10, 20);
		Cuenta c2=new CuentaCorriente(20, 30);
		
		
		lista.add(cc);
		lista.add(c2);
		
		Cuenta obtenerCuenta=(Cuenta) lista.get(0);
		
		for(int i=0;i<lista.size();i++) {
			
		System.out.println(lista.get(i));
		}
		
		for (Cuenta cuenta : lista) {
			System.out.println(cuenta);
			//imprime por cada cuenta : en la lista
		}
		
		
		
	}
	
}






ArrayList lista = new ArrayList(26); //capacidad inicial
lista.add("RJ");
lista.add("SP");
//otros estados
ArrayList nueva = new ArrayList(lista); //creando basada en la primera lista



	/////////////////////////////////////////////////////
					
									ForEach
									
			Se usa cuando no necesitamos indices y trabajamos con objectos mayoritariamente				
					Si vemos que todos son Cuentas 				
									
		for (Cuenta cuenta : lista) {
			System.out.println(cuenta);
			//imprime por cada cuenta : en la lista
		}
		
		
		
		
		/////////////////////////////////////////////////////
					
									Metodo contains()
									
Nos dice true o false si el arraylist ya contiene el elemento
		
		
		
		boolean contiene=lista.contains(c2);
		if(contiene) {
			System.out.println("Si");
		}
		
		
		
		
		
		/////////////////////////////////////////////////////
					
									Metodo equals(Object obj)
									
									
					No es del paquete java.util 
					El metodo Contains utiliza internamente el metodo equals
					
					
					
					@Override
    public boolean equals(Object obj) {
	   Cuenta cuenta=(Cuenta)obj;
	   System.out.println("hola");
	   return this.agencia==cuenta.getAgencia() && this.numero==cuenta.getNumero();
	   
    }
    
    
    
    
    	//por referencia 
		boolean contiene=lista.contains(c2);
		if(contiene) {
			System.out.println("Si, es igual por equals");
		}
		
		
		
		
		
		
		
		---------------------------------------------------------------------------------------------------------
		///////////////////////////////////////////////////////////////////////////////////////////////////////	
								LinkedList en Java
								o lista enlazada	
									
				Esto ya no es array, es una estructura de datos pero tmabien es una lista.Es un conjunto de objetos en el que
				cada objecto sabe cual es su objeto anterior. Cada obj se llama nodo, es un nodo de la lista enlazada
				Beneficios:
				Eliminar elementos o agregar elementos en orden especifico sin necesidad de recorrer todo el array
				Contras:
				Si tenemos que iterar la lista inpacta un poco en el performance
				
				
				
		package com.bytebank.test;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import com.bytebank.modelo.Cliente;
import com.bytebank.modelo.Cuenta;
import com.bytebank.modelo.CuentaCorriente;

public class TestArrayList {

	
	public static void main(String[] args) {
		
		
		SOLO CON INSTANCIAR LA INTERFAZ LIST Y LUEGO LA CLASE LINKEDLIST FUNCIONA IGUAL
		AQUI LA IMPLEMENTACION DE LA LISTA YA NO ES PARA NADA IGUAL A LA QUE HICIMOS
		A GUARDA REFERENCIAS POR QUE YA NO ESTAMOS USANDO ESA ESTRUCTURA DE DATOS, EL ARRAY ESTATICO 
		
		List<Cuenta> lista=new LinkedList<>();
		//ArrayList<Cuenta> lista=new ArrayList<>();
		
		Cuenta cc=new CuentaCorriente(10, 20);
		Cuenta c2=new CuentaCorriente(20, 30);
		Cuenta c3=new CuentaCorriente(20, 30);
		
		lista.add(cc);
		lista.add(c2);
		lista.add(c3);
		
		Cuenta obtenerCuenta=(Cuenta) lista.get(0);
		
		for(int i=0;i<lista.size();i++) {
			
		System.out.println(lista.get(i));
		}
		
		for (Cuenta cuenta : lista) {
			System.out.println(cuenta);
			//imprime por cada cuenta : en la lista
		}
		
		boolean contiene=lista.contains(c2);
		if(contiene) {
			System.out.println("Si, es igual por equals");
		}

	}
	
}
				
				
				
				
	---------------------------------------------------------------------------------------------------------
		///////////////////////////////////////////////////////////////////////////////////////////////////////	
												
				