-----------------------------------------------------------------------------------------------
						TEORIA POLIMORFISMO
						
Es muy importante para tener un codigo limpio, donde podemos modificar 
un solo metodo de la clase padre y asi en cascada nos cambiara solo el resultado


		metodo padre						
		
 
	public double getBonificacion() {
		//si tipo 1==1 es gerente
		//si tipo==0 es funcionario
		return this.salario*0.1;
		
	}
	
	
	
	metodo hijo
	
	
	//sobreescritura de metodo
	public double getBonificacion(){
		return super.getSalario()+super.getBonificacion();
	}
	
	
	
	//INTRODUCCION A POLIMORFISMO
	
	
public class TestReferencia {

	
	
	public static void main(String[] args) {
		
		//todo gerente es funcionario, hereda de funcionario
		Funcionario funcioario=new gerente();
		funcioario.setNombre("Diego");
		
		gerente gerente=new gerente();
		gerente.setNombre("Jimena");
		
		funcioario.setSalario(2000);
		gerente.setSalario(10000);
		
		
	}
	
	
	
}
	
	
	
	
	NO todo FUNCIONARIO es Gerentepor eso no compila el codigo y no cumple con la gerencia y el polimorfismo 
	
	
	public class TestReferencia {

	
	
	public static void main(String[] args) {
		
		//todo gerente es funcionario, hereda de funcionario
		Funcionario funcioario=new gerente();
		funcioario.setNombre("Diego");
		
		
		//NO FUNCIONA EL POLIMORFISMO
		gerente gerente=new Funcionario();
		gerente.setNombre("Jimena");
		
		funcioario.setSalario(2000);
		gerente.setSalario(10000);
		
		
	}
	
	
	
}
	
	
	/////////////////////////
	
	Cuando por parametro paso una clase o un objecto, eso significa que lo instanciamos
	por lo tanto se registra como que lo llamamos y se dispara el metodo
	
	voy a ir sumando poco a poco en suma la bonificacion cada vez que resgistre un nuevo funcionario/
	gerente
	
	
	
	public double registrarSalario(Funcionario funcionario) {
		
		
		this.suma=funcionario.getBonificacion()+this.suma;
		return suma;
	}
	
	public double resgistrarSalario(gerente gerente) {
		this.suma=gerente.getBonificacion()+this.suma;
		return suma;
		
	}
	
	///////////////////////////////////////
	
	POLIMORFISMO EN LA CLASE CONTROLBONIFICACION
	
	
	SI tuvieramos que crear siempre un nuevo tipo de Funcionario, tendriamos que crear muchos metodos
	de RegistrarSalario por cada uno, ENTONCES la solucion es crear un solo metodo aceptando como parametro
	un Funcionario que heredara a sus clases hijos el metodo RegistrarSalario 
	
	
	----------de esto
	
	
	
public class ControlBonificacion{
	
	
	
	private double suma;
	 
	
	public double registrarSalario(Funcionario funcionario) {
		
		
		this.suma=funcionario.getBonificacion()+this.suma;
		System.out.println("calculo actual: "+this.suma);
		return this.suma;
	}
	
	public double resgistrarSalario(gerente gerente) {
		this.suma=gerente.getBonificacion()+this.suma;
		System.out.println(this.suma);
		return this.suma;
		
	}
	
	
	
}



---------------a esto



public class ControlBonificacion{
	
	
	
	private double suma;
	 
	
	public double registrarSalario(Funcionario funcionario) {
		
		
		this.suma=funcionario.getBonificacion()+this.suma;
		System.out.println("calculo actual: "+this.suma);
		return this.suma;
	}

	
	
	
}
	
	
	///////////////////////////////////
	
	
	Sobreescritura de constructores 
	
	
	Para tomar los parametros de una clase padre tenemos que usar la palabra clave 
	Super en la clase hija, creando un constructor con los parametros de la clase padre
	y pasando con el super ese parametro a la calse padre, el super esta adentro del constructor
	
	
	
	La clase PAdre:
	
	
public class Cuenta {
			
	

		double saldo;
		int agencia;
		int numero;
		Cliente titular;
		
		
		


		public Cuenta(int agencia) {
			super();
		
			if(agencia<=0) {
				System.out.println("No se permite 0");

				this.agencia = 1;
			
			}else {
				this.agencia=agencia;
			}
			total++;
			
			System.out.println("Se van creando: "+ total+ " de cuentas.");
		}
		
		
		
		
		clase hijas:
		
		
		
public class CuentaCorriente extends Cuenta {

	
	public CuentaCorriente(int agencia) {
		super(agencia);
	}
	
	
	
}
		
		
		
		
public class CuentaAhorro extends Cuenta {
  public CuentaAhorro(int agencia) {
		super(agencia);
		// TODO Auto-generated constructor stub
	}
}
		
	
	
	
	
	
	
	
	///////////////////////////////////
	
	Modificadores de acceso

Los modificadores de acceso o accesibilidad son algunas palabras claves utilizadas en el lenguaje Java para definir el nivel de accesibilidad que los elementos de una clase (atributos y métodos) e incluso la propia clase puede tener los mismos elementos de otra clase.

Public

Este es el modificador menos restrictivo de todos. De esta manera, cualquier componente puede acceder a los miembros de la clase, las clases y las interfaces.

Protected

Al usar este modificador de acceso, los miembros de la clase y las clases son accesibles para otros elementos siempre que estén dentro del mismo package o, si pertenecen a otros packages, siempre que tengan una relación extendida (herencia), es decir, las clases secundarias pueden acceder a los miembros de su clase principal (o clase de abuelos, etc.).

Private

Este es el modificador de acceso más restrictivo de todos. Solo se puede acceder a los miembros definidos como privados desde dentro de la clase y desde ningún otro lugar, independientemente del paquete o la herencia.
	